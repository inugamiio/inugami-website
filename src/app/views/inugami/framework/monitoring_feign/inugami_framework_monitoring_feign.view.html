<section id="framework-getting-started" class="page-section">
  <div class="page-section-content">
    <aside class="bd-sidebar">
      <framework-aside></framework-aside>
    </aside>
    <div class="bd-content">
      <section>
        <header>
          <h1>Inugami Framework : Monitoring Feign</h1>
        </header>


        <!--################################################################################################
        # MAIN
        #################################################################################################-->
        <main>
          <p>
            Spring Cloud Feign has established itself as the go-to solution for web service integration within the
            Spring Boot ecosystem. This library allows developers to create the necessary connectors for invoking
            and decoding web services simply by defining a Java interface.

            However, while Feign handles service calls efficiently, it lacks comprehensive out-of-the-box monitoring.
            Monitoring your application's external calls is crucial for several reasons:
          </p>

          <dl>
            <dt>Auditability</dt>
            <dd>Knowing exactly which web service was invoked and when.</dd>

            <dt>Observability</dt>
            <dd>Capturing the precise response and payload for troubleshooting and performance tracking.</dd>
          </dl>

          <inu-copy icon="maven" label="copy maven dependency" [content]="mavenDependencies()"></inu-copy>
          <div>
            <inu-code url="data/inugami/framework/feign.xml" tag="dependencies_maven"></inu-code>
          </div>


          <inu-copy icon="java" label="copy java dependency" [content]="javaDependencies()"></inu-copy>
          <div>
            <inu-code url="data/inugami/framework/feign.xml" tag="dependencies_java"></inu-code>
          </div>

          <inu-cite level="success" title="Native SSRF protection ">
            By default, Inugami configures Feign to protect the library against SSRF (Server-Side Request Forgery)
            attacks.
          </inu-cite>

          <!--****************************************************************************************
          ** Integration
          ****************************************************************************************-->
          <article>
            <header>
              <a [routerLink]="['/inugami/framework/monitoring-feign']"><h2 id="integration">Integration</h2></a>
            </header>

            <p>
              Once the Maven dependency and the JPMS (Java Module System) dependencies have been added to your
              project, you simply need to enable annotation scanning for the Inugami packages.
            </p>
            <inu-code url="data/inugami/framework/source_code.xml" tag="SpringBootITConfiguration"></inu-code>

            <p>
              Applying this configuration ensures that the entire Inugami Feign stack—including decoders and
              interceptors—is initialized and functional.
              Nonetheless, <strong>we recommend</strong> using a <strong>fine-grained configuration</strong> for your
              Feign client declarations.
            </p>
          </article>

          <!--****************************************************************************************
          ** step by step
          ****************************************************************************************-->
          <article>
            <header>
              <a [routerLink]="['/inugami/framework/monitoring-feign']"><h2 id="steps">Step by step</h2></a>
            </header>

            <p>
              To understand how to properly integrate a Feign client, we will use a publicly available web service as
              an example. There is a freely accessible web service providing Swiss weather data. It is the perfect
              candidate for Inugami integration. The service is available at the following URL:
              <code>https://api.open-meteo.com/v1/forecast?latitude=46.2831&longitude=6.1673&current_weather=true</code>
            </p>
            <inu-code url="data/inugami/framework/feign.xml" tag="weather_swiss_response"></inu-code>

            <p>
              This example is based on the architecture outlined in the
              <a  [routerLink]="['/inugami/framework/getting-started']" fragment="archetype">Getting Started</a> section.

            </p>

            <figure class="padding-right-4">
              <img src="images/framework/feign-01.png" alt="integration of feign into infrastructure layer" width="320px" />
            </figure>

            <p>
              The starting point involves defining the specific model for our partner inside the infrastructure layer.
            </p>
            <inu-code url="data/inugami/framework/feign.xml" tag="WeatherResponseDTO"></inu-code>
            <inu-code url="data/inugami/framework/feign.xml" tag="CurrentWeatherDTO"></inu-code>
            <inu-code url="data/inugami/framework/feign.xml" tag="WeatherConditionType"></inu-code>

            <p>
              After defining the model, we can move on to creating the actual Feign interface.
            </p>
            <inu-code url="data/inugami/framework/feign.xml" tag="OpenMeteoWeather"></inu-code>
            <p>
              What stands out here is that the Feign interface is completely devoid of any Feign-specific annotations.
              This is perfectly normal, as its conversion into a Feign client will be handled within a configuration
              bean. The goal of this approach is to strictly follow the same pattern used for our own web service
              integrations. Consequently, we only use standard Spring Web annotations
            </p>

            <p>
              Configurations should never be hardcoded. Following Spring Boot best practices, we use
              <code>ConfigurationProperties</code> to create a dedicated configuration object.
            </p>
            <inu-code url="data/inugami/framework/feign.xml" tag="OpenMeteoProperties"></inu-code>

            <p>
              All that’s left is to let the magic happen. To do this, we add a configuration bean to define our Feign client.
            </p>
            <inu-code url="data/inugami/framework/feign.xml" tag="OpenMeteoConfiguration"></inu-code>

            <p>
              What we can observe is that the openMeteoFeignBuilder is the first bean to be constructed. This
              <em>Inugami-provided</em> object assists us in building our Feign clients. In our example, we have only
              one service, but you can quickly reach a multitude of Feign services. This approach centralizes and
              mutualizes the configuration.
            </p>

            <p>
              Using this builder leads to a significant reduction in the complexity of your Feign client setup.
            </p>

            <p>
              From this point on, your DAO can inject the Feign client and invoke the web service. In a
              <em>Hexagonal Architecture approach</em>, we never use a partner's raw data directly within our application.
              We must map them onto internal DTOs belonging to the application's model.
            </p>
            <inu-code url="data/inugami/framework/feign.xml" tag="WeatherDAO"></inu-code>


            <inu-code url="data/inugami/framework/feign.xml" tag="PARTNERLOG_logs"></inu-code>

            <p>
              When invoking our web service, the DAO uses our Feign client to retrieve data. During this call, a
              <em>PARTNERLOG</em> entry is emitted. Upon reception, a second log traces the partner's response.
              These logs are, of course, indexable in an engine like Elasticsearch, allowing you to take full
              advantage of the MDC keys generated by Inugami for Feign calls.
            </p>

            <inu-cite level="success" title="Full example">
              You can find the complete integration example in the demo project:
              <a href="ttps://github.com/inugamiio/inugami-demo" target="_blank">ttps://github.com/inugamiio/inugami-demo</a>
            </inu-cite>
          </article>

          <!--****************************************************************************************
          ** configuration
          ****************************************************************************************-->
          <article>
            <header>
              <a [routerLink]="['/inugami/framework/monitoring-feign']"><h2 id="configs">Configuration</h2></a>
            </header>
            <p>
              As mentioned above, Inugami natively protects against SSRF (Server-Side Request Forgery) attacks.
              Calls to partner addresses on <em>localhost</em> are <strong>restricted</strong>. An error will be
              automatically triggered in such cases.
            </p>
            <inu-code url="data/inugami/framework/feign.xml" tag="SSRF"></inu-code>

            <p>
              In the case of integration tests using WireMock, however, it is necessary to allow this type of action.
              You must therefore add the following property to your test configuration:
            </p>
            <inu-code url="data/inugami/framework/feign.xml" tag="configSSRF"></inu-code>
          </article>


          <article>
            <header>
              <a [routerLink]="['/inugami/framework/monitoring-feign']"><h2 id="mdc">MDC</h2></a>
            </header>


            <strong>Partner Information</strong>
            <dl>
              <dt>partner</dt>
              <dd>The high-level name of the integrated partner (e.g., openmeteo).</dd>

              <dt>partnerService</dt>
              <dd>The specific service being called.</dd>

              <dt>partnerSubService</dt>
              <dd>The specific operation or endpoint within the service.</dd>

              <dt>partnerType</dt>
              <dd>The nature of the partner (e.g., REST, SOAP, JMS).</dd>

              <dt>partnerUrl</dt>
              <dd>The full target URL of the request.</dd>

              <dt>partnerVerb</dt>
              <dd>The HTTP method used (e.g., GET, POST, PUT).</dd>
            </dl>


            <strong>Request & Response Metadata</strong>
            <dl>
              <dt>partnerRequestCharset</dt>
              <dd>The character encoding of the outgoing request.</dd>

              <dt>partnerResponseCharset</dt>
              <dd>The character encoding of the incoming response.</dd>

              <dt>partnerResponseDuration</dt>
              <dd>The total execution time of the call in milliseconds.</dd>

              <dt>partnerResponseStatus</dt>
              <dd>The HTTP status code returned by the partner (e.g., 200, 404, 500).</dd>

              <dt>partnerResponseMessage</dt>
              <dd>The raw status text or summary of the response.</dd>
            </dl>


            <strong>Advanced Error Diagnostics</strong>
            <dl>
              <dt>errorDomain</dt>
              <dd>Main service domain (e.g., USER, CARD, PAYMENT).</dd>

              <dt>errorType</dt>
              <dd>The specific category of error (e.g., functional, technical, security).</dd>

              <dt>errorCategory</dt>
              <dd>A grouping for similar error types to simplify reporting.</dd>

              <dt>errorCode</dt>
              <dd>A unique functional or technical code identifying the specific error.</dd>

              <dt>errorMessage</dt>
              <dd>A concise human-readable error summary.</dd>

              <dt>errorMessageDetail</dt>
              <dd>Extensive details about the failure (e.g., stack trace snippet or raw error body).</dd>

              <dt>errorField</dt>
              <dd>If applicable, the specific data field that caused a validation error.</dd>

              <dt>errorStatus</dt>
              <dd>The internal mapping of the error status.</dd>

              <dt>errorUrl</dt>
              <dd>Link to the specific error documentation or troubleshooting guide</dd>

              <dt>errorRetryable</dt>
              <dd>A boolean (true/false) indicating if the operation can be safely retried.</dd>

              <dt>errorRollback</dt>
              <dd>Indicates if the current transaction was or should be rolled back.</dd>

              <dt>errorExploitationError</dt>
              <dd>A flag identifying critical errors that require immediate attention from the operations/SRE team.</dd>
            </dl>
          </article>

          <article>
            <header>
              <a [routerLink]="['/inugami/framework/monitoring-feign']"><h2 id="error_resolver">Error code resolver</h2></a>
            </header>



            <p>
              Inugami relies on a highly granular error code logic. However, your partners may not necessarily
              implement this logic. If that is the case, you can implement this logic within your application using the
              <code>FeignPartnerErrorResolver</code> SPI. This interface is part of a Strategy pattern within the Inugami engine's
              Feign client error interception logic.
            </p>

            <inu-cite level="success" title="Spring or SPI">
              Like all Inugami SPIs, you can implement them using either standard Java SPI mechanisms or as Spring Beans.
            </inu-cite>
            <inu-code url="data/inugami/framework/feign.xml" tag="FeignPartnerErrorResolver"></inu-code>

          </article>
        </main>
      </section>
    </div>

  </div>

</section>
