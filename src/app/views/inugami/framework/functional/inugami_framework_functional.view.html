<section id="framework-getting-started" class="page-section">
    <div class="page-section-content">
        <aside class="bd-sidebar">
            <framework-aside></framework-aside>
        </aside>
        <div class="bd-content">
            <section>
                <header>
                     <h1>Inugami Framework : Functional</h1>
                </header>

                <p>
                    Since Java 8, the introduction of lambdas has radically changed the way we develop in Java.
                    Although Java provides a solid set of standard functional interfaces, we have added a custom suite
                    of interfaces specifically tailored to the needs of the Inugami framework and the projects powered by it.
                </p>

                <cite class="success">
                    <header>
                        <i></i>
                        <div>
                            Inugami provides specialized interfaces to make your functional code cleaner, safer, and more expressive.
                        </div>
                    </header>
                </cite>
                
                <inu-copy icon="maven" label="copy maven dependency" [content]="mavenDependencies()"></inu-copy>
                <div>
                    <inu-code url="data/inugami/framework/functional.xml" tag="dependencies_maven"></inu-code>
                </div>
                

                <inu-copy icon="java" label="copy java dependency" [content]="javaDependencies()"></inu-copy> 
                <div>
                    <inu-code url="data/inugami/framework/functional.xml" tag="dependencies_java"></inu-code>
                </div>
            </section>


            <main>

                <article>
                    <header>
                        <a [routerLink]="['/inugami/framework/functional']"><h2 id="action_With_exception">ActionWithException</h2></a>
                    </header>

                   <inu-code url="data/inugami/framework/functional.xml" tag="ActionWithException"></inu-code>

                   <p>
                   The ActionWithException functional interface allows you to encapsulate an action that may potentially
                   throw an error. This error can then be caught and handled by the method consuming the interface—for
                   instance, to map the exception to a standardized error code.
                   </p>

                   <p>
                    This logic is implemented in the <code>Asserts</code> class, specifically through the <code>wrapErrorForSupplierWithException</code> method.
                   </p>
                   <inu-code url="data/inugami/framework/functional.xml" tag="ActionWithExceptionUsage"></inu-code>

                </article>

                <article>
                    <header>
                        <a [routerLink]="['/inugami/framework/functional']"><h2 id="consumer">Consumer</h2></a>
                    </header>

                    <inu-doc-item title="BiConsumerWithException" [level]="3" href="inugami/framework/functional#bi_consumer_with_exception" id="bi_consumer_with_exception">
                        <inu-code url="data/inugami/framework/functional.xml" tag="BiConsumerWithException"></inu-code>

                        <p>
                            The BiConsumerWithException functional interface allows for the invocation of a method that
                            may potentially throw an exception. This interface accepts two input parameters and is utilized,
                            for example, in Inugami's DTO validation processes (such as <code>Asserts.assertModel</code>).
                        </p>
                        <inu-code url="data/inugami/framework/functional.xml" tag="BiConsumerWithExceptionUsage"></inu-code>

                    </inu-doc-item>


                    <inu-doc-item title="ConsumerWithException" [level]="3" href="inugami/framework/functional#consumer_with_exception" id="consumer_with_exception">
                        <inu-code url="data/inugami/framework/functional.xml" tag="ConsumerWithException"></inu-code>

                        <p>
                            The <code>ConsumerWithException</code> interface is ideal for <strong>Event Dispatcher</strong> approaches. 
                            In this design pattern, listeners are invoked for notification purposes. However, since 
                            listeners execute their own specific logic upon notification, there is no guarantee that 
                            they will not encounter errors. Despite this, the service responsible for notifying these 
                            listeners should not fail as a result of a single listener's error.
                        </p>

                        <inu-code url="data/inugami/framework/functional.xml" tag="ConsumerWithExceptionUsage"></inu-code>

                        <cite class="success">
                            <header>
                                <i></i>
                                <div>
                                    Inugami's <code>RunSafeUtils</code> class
                                </div>                                
                            </header>
                            <p>
                                allows for the execution of actions that carry a risk of failure but are not critical
                                to the primary process. In such scenarios, it eliminates the need for verbose <code>try/catch blocks</code>,
                                making the code significantly more readable and maintainable
                            </p>
                        </cite>
                    </inu-doc-item>

                </article>


                <article>
                    <header>
                        <a [routerLink]="['/inugami/framework/functional']"><h2 id="function">Function</h2></a>
                    </header>

                    <inu-doc-item title="FunctionWithException" [level]="3" href="inugami/framework/functional#function_with_exception" id="function_with_exception">
                        <inu-code url="data/inugami/framework/functional.xml" tag="FunctionWithException"></inu-code>

                        <p>
                            In complex systems, data processing often follows a Chain of Command. Each step (or "link")
                            in the chain performs a specific transformation. Using FunctionWithException allows these
                            steps to perform heavy operations (DB access, specialized parsing) that might throw exceptions,
                            while keeping the orchestrator clean.
                        </p>

                        <inu-code url="data/inugami/framework/functional.xml" tag="FunctionWithExceptionUsage"></inu-code>

                    </inu-doc-item>

                    <inu-doc-item title="GenericActionWithException" [level]="3" href="inugami/framework/functional#generic_action_with_exception" id="generic_action_with_exception">
                        <inu-code url="data/inugami/framework/functional.xml" tag="GenericActionWithException"></inu-code>

                        <p>
                            The <code>GenericActionWithException</code> interface is very similar in usage to <code>FunctionWithException</code>,
                             with one key difference: it acts as a <code>Supplier</code> that takes no input parameters.
                        </p>
                      
                        <p>
                            It is designed to encapsulate a standalone operation that produces a result of type <code>T</code>
                            while allowing for the propagation of any <code>Throwable</code>. This makes it the ideal
                            choice for wrapping isolated blocks of logic, external calls, or factory methods that are 
                            prone to failure but do not require external data to execute.
                        </p>
                        
                    </inu-doc-item>

                    <inu-doc-item title="VoidFunction" [level]="3" href="inugami/framework/functional#void_function" id="void_function">
                        <inu-code url="data/inugami/framework/functional.xml" tag="VoidFunction"></inu-code>
                        <p>
                            The VoidFunction interface represents a simple command that takes no arguments and returns no result.
                        </p>
                        <p>
                            While it is structurally identical to the standard Java Runnable, it is used within the 
                            Inugami framework to clearly signal a functional 'action' or 'callback'. 
                            It is the ideal choice for triggering side effects—such as clearing a cache,  or sending a message,
                            where the execution is guaranteed not to throw checked exceptions.
                        </p>
                    </inu-doc-item>

                    <inu-doc-item title="VoidFunctionWithException" [level]="3" href="inugami/framework/functional#void_function_with_exception" id="void_function_with_exception">
                        <inu-code url="data/inugami/framework/functional.xml" tag="VoidFunctionWithException"></inu-code>
                        <p>
                            The <code>VoidFunctionWithException</code> interface is the robust counterpart to <code>VoidFunction</code>.
                            It represents a standalone action that takes no input and returns no output, but is explicitly
                            permitted to throw a checked exception.
                        </p>
                        <p>
                            It is used when you need to trigger a procedure—such as a cleanup task,
                            a file commit, or a system notification—that might fail, requiring the caller to either 
                            handle the error or delegate it to a recovery utility like RunSafeUtils.
                        </p>

                        <inu-code url="data/inugami/framework/functional.xml" tag="VoidFunctionWithExceptionUsage"></inu-code>
                    </inu-doc-item>

                    <inu-doc-item title="ValidatorFunction" [level]="3" href="inugami/framework/functional#validator_function" id="validator_function">
                        <inu-code url="data/inugami/framework/functional.xml" tag="ValidatorFunction"></inu-code>

                        <p>
                            The ValidatorFunction interface is a specialized functional contract dedicated to business
                            validation logic. Unlike a standard <code>Predicate</code> that returns a boolean, this interface
                            validates an input of type <code>T</code> and signals failure by throwing a specific exception of type <code>E</code>.
                        </p>

                        <p>
                            This approach is ideal for building validation pipelines where you need to know exactly why 
                            a validation failed. It allows developers to keep validation rules isolated, reusable, 
                            and capable of propagating detailed error contexts through structured exceptions.
                        </p>
                        <inu-code url="data/inugami/framework/functional.xml" tag="ValidatorFunctionUsage"></inu-code>
                    </inu-doc-item>
                </article>

                <article>
                    <header>
                        <a [routerLink]="['/inugami/framework/functional']"><h2 id="is_empty_facet">IsEmptyFacet</h2></a>
                    </header>
                    <inu-code url="data/inugami/framework/functional.xml" tag="IsEmptyFacet"></inu-code>

                    <p>
                        The <code>IsEmptyFacet</code> interface is a functional 'trait' used to standardize how objects
                        signal <strong>their emptiness</strong>. By implementing this interface, a class provides a
                        consistent way for orchestrators, validators to check if an object contains any meaningful data.
                    </p>
                    <p>
                        It is particularly useful in complex forms or deep data structures where you need to prune 'empty'
                        objects before persistence or transmission, ensuring that only relevant data remains
                        in your processing pipeline.
                    </p>

                    <inu-code url="data/inugami/framework/functional.xml" tag="IsEmptyFacetUsage"></inu-code>
                </article>

                <article>
                    <header>
                        <a [routerLink]="['/inugami/framework/functional']"><h2 id="supplier">Supplier</h2></a>
                    </header>
                     <inu-doc-item title="SupplierWithException" [level]="3" href="inugami/framework/functional#supplier_with_exception" id="supplier_with_exception">
                        <inu-code url="data/inugami/framework/functional.xml" tag="SupplierWithException"></inu-code>

                        <p>
                            The <code>SupplierWithException</code> interface represents a provider of results that can
                            throw a checked exception.
                        </p>
                        <p>
                            While the standard Java <code>Supplier</code> is restricted to non-throwing operations,
                            this interface allows you to encapsulate 'lazy' logic—such as fetching a secret from a vault, 
                            reading a file, or acquiring a database connection—without forcing an immediate <code>try-catch block</code>.
                            It bridges the gap between deferred execution and robust error handling
                        </p>

                        <inu-code url="data/inugami/framework/functional.xml" tag="SupplierWithExceptionUsage"></inu-code>

                        <p>
                            This example demonstrates a <code>ProductService</code> querying several regional stock services. 
                            Each regional search is wrapped in a <code>SupplierWithException</code>, allowing the orchestrator
                            to collect available stocks while gracefully handling failures in specific regions.
                        </p>

                        <strong>Key Advantages:</strong>
                        <dl>
                            <dt>Fault Tolerance</dt>
                            <dd>A failure in one regional StockService (e.g., a timeout or connection error) does not
                                crash the entire search. The error is caught and converted into a user warning.</dd>

                            <dt>Declarative Safety</dt>
                            <dd>The searchProductInRegionalStock method provides a clean, reusable template for executing 
                                "risky" suppliers.</dd>

                            <dt>Separation of Concerns</dt>
                            <dd>The business logic (findProductInStocks) focuses on the iteration, while the safety logic (searchProductInRegionalStock) focuses on exception management and state reporting.</dd>
                        </dl>
                    </inu-doc-item>


                    <inu-doc-item title="SupplierWithThrowable" [level]="3" href="inugami/framework/functional#supplier_with_throwable" id="supplier_with_throwable">
                        <inu-code url="data/inugami/framework/functional.xml" tag="SupplierWithThrowable"></inu-code>

                        <p>
                           The SupplierWithThrowable interface is the highest level of protection. It is used when
                           orchestrating multiple external providers where the reliability of the underlying code is
                           unknown or out of your control.
                        </p>

                        <p>
                            Unlike <code>SupplierWithException</code>, which only catches standard exceptions,
                            <code>SupplierWithThrowable</code> ensures that no failure whatsoever (even JVM Errors) can
                            escape the execution block and crash the main process. This allows the orchestrator to collect 
                            esults from healthy providers while converting failures into non-blocking warnings.
                        </p>
                        <inu-code url="data/inugami/framework/functional.xml" tag="SupplierWithThrowableUsage"></inu-code>
                    </inu-doc-item>
                </article>


                <article>
                    <header>
                        <a [routerLink]="['/inugami/framework/functional']"><h2 id="task">Task</h2></a>
                    </header>

                        <inu-doc-item title="TaskStartListener" [level]="3" href="inugami/framework/functional#task_start_listener" id="task_start_listener">
                            <inu-code url="data/inugami/framework/functional.xml" tag="TaskStartListener"></inu-code>
                            <p>
                                The TaskStartListener interface is a specialized observer designed for monitoring and telemetry.
                                It provides a standard contract to capture the exact moment a task begins, along with its metadata.
                            </p>
                            <p>
                                By using this interface, you can decouple your task execution logic from your monitoring
                                infrastructure. Whether you are logging to a console, sending metrics to Prometheus, or
                                tracking execution in a database, the listener ensures that your core logic remains
                                focused on the task at hand while providing full transparency into the system's activity.
                            </p>
                        </inu-doc-item>

                        <inu-doc-item title="TaskFinishListener" [level]="3" href="inugami/framework/functional#task_finish_listener" id="task_finish_listener">
                            <inu-code url="data/inugami/framework/functional.xml" tag="TaskFinishListener"></inu-code>
                            <p>
                                The TaskFinishListener interface is post-execution observability. It captures the full
                                lifecycle of a task upon completion, providing essential metrics such as execution
                                duration and delay, alongside the functional outcome (the result or the exception).
                            </p>

                            <p>
                                This interface allows for advanced telemetry, such as calculating success rates, profiling
                                slow tasks, or triggering specific alerts when an exception is captured, all while keeping
                                the business logic completely unaware of the monitoring stack.
                            </p>
                        </inu-doc-item>
                    
                </article>


                <article>
                    <header>
                        <a [routerLink]="['/inugami/framework/functional']"><h2 id="functional_utils">FunctionalUtils</h2></a>
                    </header>

                      <p>
                        While Inugami's functional interfaces provide the structure, <code>FunctionalUtils</code> provides 
                        the <strong>fluent API</strong> to use them efficiently. This utility class eliminates 
                        <strong>boilerplate</strong> code related to null checks, empty collections, and state changes.
                    </p>

                    <inu-code url="data/inugami/framework/functional.xml" tag="FunctionalUtils"></inu-code>
                 

                    <p>
                        The <code>FunctionalUtils</code> class is a comprehensive utility library designed to make Java
                        code more declarative and readable. Its primary goal is to eliminate the "visual noise" created
                        by defensive programming, such as repetitive null-checks and empty-state validations.
                    </p>
                    <p>
                        By providing a fluent API, it allows developers to express intent—telling the code what to do
                        rather than focusing on the boilerplate of how to check for safety.
                    </p>

                    <p><strong>Fallback & Default Values</strong></p>
                    <p>
                        These methods simplify the process of ensuring a variable always has a valid value, acting as
                        a more concise alternative to the standard Optional API.
                    </p>
                    <dl>
                        <dt>or(T value, T ref)</dt>
                        <dd>Returns the reference value if the provided value is null.</dd>

                        <dt>or(T value,{{supplier_T()}} ref)</dt>
                        <dd>A "lazy" version that only executes the supplier if the
                            value is missing, saving computational resources.</dd>
                    </dl>

                    <p><strong>Null-Safe Execution</strong></p>
                    <p>
                        This is the core of the utility, replacing traditional if (object != null) blocks with functional triggers.
                    </p>
                    <dl>
                        <dt>applyIfNotNull(data, consumer)</dt>
                        <dd>Executes a <code>Consumer</code> action only if the data is present. It returns a boolean, 
                            allowing for conditional branching based on whether the action occurred.</dd>

                        <dt>ifNotNull(value, processor)</dt>
                        <dd>Maps a value to a new result using a Function, but safely returns null if the input was null.</dd>

                        <dt>processIfNotNull(object, VoidFunction)</dt>
                        <dd>Triggers a side-effect (via <code>VoidFunction</code>) only if the object is not null.</dd>
                    </dl>


                    <p><strong>Collection & String Sanitization</strong></p>
                    <p>
                        Standard Java often requires checking both for null and isEmpty(). 
                        These methods unify those checks into a single call.
                    </p>
                    <dl>
                        <dt>applyIfEmpty(data, supplier)</dt>
                        <dd>Works for <strong>Strings, Collections, and Maps</strong>. If the input is null or empty, it provides a fallback
                             (e.g., initializing an empty list to avoid downstream errors).</dd>

                        <dt>orNull(data)</dt>
                        <dd>A specific cleaner for Strings that converts blank or whitespace-only strings into a true
                            <code>null</code>, standardizing data before persistence.</dd>
                    </dl>


                    <p><strong>State Change Tracking :</strong>
                        An advanced feature for optimizing performance and auditing data modifications.
                    </p>
                    <dl>
                        <dt>applyIfChange(ref, newValue, consumer)</dt>
                        <dd>Compares two values (primitive or object). The Consumer is triggered 
                            only if the value has actually changed.</dd>

                        <dt>hasChange(ref, newValue)</dt>
                        <dd>A robust null-safe comparison tool that correctly handles cases where either the reference 
                            or the new value might be null, avoiding <code>NullPointerExceptions</code> 
                            during equality checks.</dd>
                    </dl>

                </article>

            </main>
        </div>
    </div>
</section>