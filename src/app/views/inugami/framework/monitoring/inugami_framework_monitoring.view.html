<section id="framework-getting-started" class="page-section">
    <div class="page-section-content">
        <aside class="bd-sidebar">
            <framework-aside></framework-aside>
        </aside>
        <div class="bd-content">
            <section>
                    <header>
                    <h1>Inugami Framework : Monitoring</h1>
                </header>

                <!--################################################################################################
                # MAIN
                #################################################################################################-->
                <main>
                        <p>
                           Monitoring is a vital aspect of an application that should be considered from the design phase.
                           Retrofitting it into an existing system is a significant challenge.
                        </p>
                        <p>
                           Achieving granular application monitoring is a major challenge. Experience in extreme
                           operational environments shows that attempting to build such a solution without a dedicated
                           framework often leads to prohibitive technical debt.
                        </p>
                        <p>
                            Inugami was born from the need to supervise a massive mobile application, utilizing multiple
                            datacenters for its backend, all while maintaining an operational quality that allowed no
                            more than 5 minutes of annual downtime. The insights gained from these extreme constraints
                            led to the comprehensive suite of monitoring tools now integrated into Inugami.
                        </p>

                        <p>
                            A properly monitored application must provide real-time, precise insight into exactly what 
                            it is doing and whether its behavior is normal. Logs are the richest source of information 
                            an application can produce. They should not be viewed as an infrastructure cost, but as a
                            goldmine of information—not only for technical health but, more importantly,
                            for business intelligence.
                        </p>
                        <cite class="success">
                            <header>
                                <i></i>
                                <div>
                                   The real question we must ask ourselves is:
                                    how much will an application failure <strong>cost</strong> us—both in terms of <strong>reputation and financial impact</strong>?
                                </div>
                            </header>
                        </cite>

                                     
                        <inu-copy iconClass="icon ico-maven" label="copy maven dependency" [content]="mavenDependencies()"></inu-copy>
                        <div>
                            <inu-code url="data/inugami/framework/monitoring.xml" tag="dependencies_maven"></inu-code>
                        </div>
                        

                        <inu-copy iconClass="icon ico-java" label="copy java dependency" [content]="javaDependencies()"></inu-copy> 
                        <div>
                            <inu-code url="data/inugami/framework/monitoring.xml" tag="dependencies_java"></inu-code>
                        </div>
                        

                         <!--****************************************************************************************
                        ** GETTING STARTED
                        ****************************************************************************************-->
                        <article>
                            <header>
                                <a [routerLink]="['/inugami/framework/monitoring']"><h2 id="getting-started">Getting started</h2></a>
                            </header>

                            <p>
                               Inugami’s <a routerLink="/inugami/framework/exception">exception management documentation</a> highlights the framework’s extensive use of
                               the MDC (<strong>Mapped Diagnostic Context</strong>) to track errors. This management goes far beyond simple
                               logging. it is the very heart of Inugami’s monitoring strategy.
                            </p>

                            <p>
                                To unlock the full potential of logs, a tool capable of consuming a high-speed JSON
                                stream is essential. While several options exist, such as ElasticSearch/Kibana, Datadog or Splunk.
                            </p>
                            <cite class="success">
                                <header>
                                    <i></i>
                                    <div>
                                        the solution that is by far the most straightforward, performant, and advanced
                                        is Elasticsearch coupled with Kibana.
                                    </div>
                                </header>
                                <p>
                                    For more information on Elasticsearch and Kibana, you can visit 
                                    <a href="https://www.elastic.co/" target="_blank">the official website</a>, 
                                    which offers extensive documentation on the vast capabilities of these tools.
                                </p>
                            </cite>

                            <cite class="info">
                                <header>
                                    <i></i>
                                    <div></div>
                                </header>
                                <p>
                                    To demonstrate Inugami’s monitoring capabilities, the choice was made to integrate
                                    it with Elasticsearch and Kibana for this demo. The concepts discussed are generic
                                    and can be transposed to other tools. Only the creation and usage of information
                                    within the observation tool will differ.
                                </p>
                            </cite>


                            <p>
                                The objective of this demo is to demonstrate how to set up a relatively comprehensive
                                dashboard, all in a very simple manner. The dashboard in question is as follows:
                            </p>
                            <figure>
                                <img src="images/framework/kibana_low.png" alt="Kibana dashboard" width="90%" />
                                <caption>
                                    <a href="images/framework/kibana.png" target="_blank">Show full size</a>
                                </caption>
                            </figure>
                            

                            <inu-doc-item title="Dependencies and configurations" [level]="3" href="inugami/framework/monitoring#dependencies" id="dependencies">
                                <cite class="info">
                                    <header>
                                        <i></i>
                                        <div>
                                            The example is based on the Inugami Maven archetype. 
                                        </div>
                                    </header>
                                    <p>
                                        For more information, please refer to the documentation:  <a  [routerLink]="['/inugami/framework/getting-started']" fragment="archetype">Archetype</a>.
                                    </p>
                                </cite>
                                <p>
                                    To enable monitoring in your application, you must add the following modules:
                                </p>


                                <dl>
                                    <dt>io.inugami.framework.interfaces (inugami_api_interfaces)</dt>
                                    <dd>The core of Inugami's interfaces and DTOs.</dd>

                                    <dt>io.inugami.framework.commons.spring (inugami_commons_spring)</dt>
                                    <dd>Inugami is agnostic of dependency injection engines (such as Spring or CDI).
                                        this module is required to expose its features through a specific injection engine.</dd>

                                    <dt>io.inugami.monitoring.springboot (inugami_monitoring_springboot)</dt>
                                    <dd>To enable monitoring for Spring Boot applications.</dd>

                                    <dt>io.inugami.logs.obfuscator (inugami_logs_obfuscator)</dt>
                                    <dd>Enables log obfuscation and includes appenders to transform logs into JSON format.</dd>

                                    <dt>io.inugami.monitoring.sensors.defaults (inugami_monitoring_sensors_default)</dt>
                                    <dd>To include Inugami's default technical sensors.</dd>

                                    <dt>io.inugami.monitoring.providers.logs (inugami_monitoring_providers_log)</dt>
                                    <dd>Enables the transmission of indicators via logs.</dd>
                                </dl>

                                <p>
                                    Your webapp module's <code>module-info.java</code> should look like this:
                                    <inu-code url="data/inugami/framework/monitoring.xml" tag="module_java_webapp"></inu-code>
                                </p>

                                <p>
                                    Logs must be transmitted to Elasticsearch in JSON format. To do this,
                                    the <code>io.inugami.logs.obfuscator.appender.JsonAppender</code> must be added to your <strong>logback.xml</strong> configuration.
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="elastic_appender"></inu-code>
                                <p>
                                    The <em>JsonAppender</em> requires several configuration parameters:
                                </p>

                                 <dl>
                                    <dt>mode</dt>
                                    <dd>Defines the provider for writing logs. Available modes are: file (default), elasticSearch, or logstash.</dd>
                                    
                                    <dt>host</dt>
                                    <dd>Specifies the service URL when using elasticSearch or logstash mode. </dd>
                                    
                                    <dt>headersMap</dt>
                                    <dd>Allows you to specify authentication or custom headers if your Elasticsearch instance requires them.</dd>
                                    
                                    <dt>index</dt>
                                    <dd>The Elasticsearch index name. This name is crucial for managing different environments and index retention policies.</dd>
                                    
                                    <dt>indexDatePattern</dt>
                                    <dd>Applies a time-based pattern to the index name to manage log retention. Log eviction is handled by deleting old indexes.</dd>
                                </dl>
                                    
                                <cite class="success">
                                    <header>
                                        <i></i>
                                        <div>
                                            By default, the <em>JsonAppender</em> sends logs to Elasticsearch using <em>Bulk</em> mode to ensure faster transmission speeds.
                                        </div>
                                    </header>
                                </cite>

                                <p>
                                    To implement an effective log retention policy, it is imperative to split logs across different appenders.
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="logback_full"></inu-code>
                                
                                <p>
                                    By default, the log level is set to <code>DEBUG</code>. This is not an error, but a deliberate
                                    choice to encourage configuring logs during the development phase to ensure they
                                    are properly categorized. Consequently, you can switch to INFO in production without
                                    worrying about log volume, while retaining the ability to safely switch back to
                                    DEBUG if necessary.
                                </p>

                                <p>
                                    By default, the Logback configuration outputs logs through two main appenders: the Standard Output
                                    (rendered asynchronously via AsyncAppender) and Elasticsearch (via the JsonAppender, which is natively asynchronous).
                                </p>
                                <p>
                                    The following specialized JsonAppenders are available:
                                </p>
                                
                                <dl>
                                    <dt>ELASTIC-DEFAULT</dt>
                                    <dd>The default appender that routes all standard logs to Elasticsearch.</dd>
                                    
                                    <dt>ELASTIC-IOLOG</dt>
                                    <dd>Dedicated to Input/Output logs (IOLOG), capturing request and response payloads.</dd>
                                    
                                    <dt>ELASTIC-PARTNERLOG</dt>
                                    <dd>Dedicated to communication logs with external web services (PARTNERLOG).</dd>
                                    
                                    <dt>ELASTIC-XLLOG</dt>
                                    <dd>Reserved for critical infrastructure logs.</dd>
                                    
                                    <dt>ELASTIC-METRICS</dt>
                                    <dd>Dedicated to KPI and performance indicators.</dd>
                                </dl>

                                <p>
                                    Each appender targets a different index, allowing for granular control over retention policies based on the nature of the logs.
                                </p>

                                <p>
                                    Logs may contain sensitive information. To prevent data leakage, Inugami mandates
                                    the use of the <em>ObfuscatorEncoder</em>. This Logback encoder enables the obfuscation
                                    of sensitive data <strong>through strategies</strong> defined via <em>SPI</em> (Service Provider Interface).
                                </p>

                                <p>The ObfuscatorEncoder also requires several parameters:</p>
                                <dl>
                                    <dt>forceNewLine</dt>
                                    <dd>Primarily used for file mode, this parameter forces a line break at the end of each log entry.</dd>

                                    <dt>encodeAsJson</dt>
                                    <dd>Enables the conversion of logs into JSON format.</dd>

                                    <dt>additionalFields</dt>
                                    <dd>You may need to include "static" information in your logs (such as cluster name, pod ID, etc.).
                                        These infrastructure-specific details can be defined within this parameter.</dd>

                                    <dt>pattern</dt>
                                    <dd>When serializing to JSON, a complex log pattern is no longer necessary.
                                         only the message is required. All other metadata will be transmitted 
                                         via the MDC context.</dd>
                                </dl>


                                <p>
                                    To ensure Inugami can monitor your application correctly, you must provide the following configuration to your project:
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="application.yaml"></inu-code>

                                <dl>
                                    <dt>env</dt>
                                    <dd>Defines your application's execution environment. This indicator will be included in all logs and metrics.</dd>

                                    <dt>application</dt>
                                    <dd>Configures the core information of the application (such as its groupId, artifactId, version, etc.).</dd>

                                    <dt>inugami.monitoring</dt>
                                    <dd>General configuration for Inugami monitoring.</dd>

                                    <dt>inugami.monitoring.interceptors.kpi</dt>
                                    <dd>Enables the KPI extractor for all incoming and outgoing requests of your application.</dd>

                                    <dt>inugami.monitoring.internal.interval</dt>
                                    <dd>Sets the default time interval between each metric transmission. The default is 
                                        <em>1 minute</em>, but for the purpose of this demo, it is reduced to 10 seconds (defined in milliseconds).</dd>

                                    <dt>inugami.monitoring.interceptor.url.skip</dt>
                                    <dd>Used to exclude specific URLs from Inugami monitoring (such as OpenAPI/Swagger views).</dd>

                                    <dt>inugami.monitoring.exception.show.detail.enabled</dt>
                                    <dd>Determines whether error details should be displayed. This parameter should be set to false in production environments.</dd>
                                </dl>


                                <p>
                                    To finalize your application's configuration, you simply need to enable Inugami by
                                    adding the Inugami base package to your <code>@ComponentScan</code> annotation.
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="springboot_application"></inu-code>

                                <p>
                                     <a  [routerLink]="['/inugami/framework/getting-started']" fragment="archetype">The archetype</a> includes a Docker 
                                     configuration file to spin up an Elasticsearch and Kibana instance, allowing you to test log transmission directly.
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="docker_compose"></inu-code>

                                <inu-code url="data/inugami/framework/monitoring.xml" tag="docker_compose_up"></inu-code>

                                <p>
                                    Once Elasticsearch and Kibana are up and running, you can import the Kibana configuration file included in the archetype.
                                </p>

                                <figure>
                                    <img src="images/framework/kibana_import.png" alt="Kibana import" width="90%" />
                                </figure>

                                <cite class="success">
                                    <header>
                                        <i></i>
                                        <div>The environment is ready</div>
                                    </header>
                                    <p>
                                        all that’s left is to start the application to see the logs appear in Kibana.
                                        You can use the Postman collection provided in the archetype to call the various URLs of the demo application.
                                    </p>
                                </cite>
                                
                                <figure>
                                    <img src="images/framework/kibana_low.png" alt="Kibana dashboard" width="90%" />
                                    <caption>
                                        <a href="images/framework/kibana.png" target="_blank">Show full size</a>
                                    </caption>
                                </figure>

                                <cite class="success">
                                    <header>
                                        <i></i>
                                        <div>
                                            <strong>Seamless Spring Boot Ecosystem Integration</strong>
                                            <p>
                                                Inugami isn't just a library; it's a natural extension of the Spring Boot ecosystem. 
                                                By leveraging component scanning, it delivers an enterprise-grade 
                                                monitoring stack—including Bulk ingestion and SPI obfuscation in minutes. 
                                                What would normally take months of senior-level R&D to build from scratch is activated 
                                                instantly without ever polluting your business logic.
                                            </p>
                                        </div>
                                    </header>
                                </cite>
                            </inu-doc-item>
                        </article>


                        <!--****************************************************************************************
                        ** Lifecycle
                        ****************************************************************************************-->
                        <article>
                            <header>
                                <a [routerLink]="['/inugami/framework/monitoring']"><h2 id="lifecycle">Application Lifecycle & User Journey Tracking</h2></a>
                            </header>

                             <figure>
                                <img src="images/framework/lifecycle.svg" alt="Lifecycle" width="90%" />
                                <figcaption>
                                    The Inugami traceability stack: 
                                    From persistent device identification to granular request logging (IOLOG/PARTNERLOG).
                                </figcaption>
                            </figure>

                            <p>
                                When using an application, a specific lifecycle occurs. Upon login, the user makes an initial
                                call from the frontend. The backend is then invoked to process the request, potentially
                                calling external web services to complete parts of the processing, before finally responding to the frontend.
                            </p>

                            <p>
                                This process repeats multiple times throughout the user's session. Later, the user may
                                return and perform new operations. The question is: how can we trace this entire journey?
                            </p>


                            <strong>
                                Inugami provides several trackers to reconstruct user actions:
                            </strong>

                            <dl> 
                                <dt>x-device-identifier</dt>
                                <dd>A unique ID per user, generated when the application is first installed or during
                                    the first web page load. This identifier is stored on the frontend and transmitted
                                    with every request.
                                </dd>

                                <dt>x-correlation-id</dt>
                                <dd>
                                    The identifier for the user's specific session.
                                </dd>

                                <dt>x-b3-traceid</dt>
                                <dd>
                                    The ID for the current request. This identifier is propagated during calls to internal web services.
                                </dd>

                                <dt>x-conversation-id</dt>
                                <dd>
                                    To track a specific business process, it may be necessary to generate a dedicated identifier.
                                    This ID is managed by the frontend and propagated through all sub-services.
                                </dd>
                            </dl>
                            <p>
                                Log Generation: Upon receiving a request, each web service generates two <strong>IOLOG</strong>
                                (in and out) to track received and emitted information. During calls to external web services,
                                the calling application generates two PARTNERLOGs (in and out) to trace inter-service communications.
                            </p>
                        </article>

                        <!--****************************************************************************************
                        ** Logs type
                        ****************************************************************************************-->
                        <article>
                            <header>
                                <a [routerLink]="['/inugami/framework/monitoring']"><h2 id="logs-types">Logs types</h2></a>
                            </header>


                            <inu-doc-item title="IOLOG" [level]="3" href="inugami/framework/monitoring#logs-types-iolog" id="logs-types-iolog">
                                <p>
                                    IOLOGs are the cornerstone of application observability. By providing an exhaustive audit trail 
                                    of every incoming and outgoing exchange, they allow developers to accurately reconstruct 
                                    and replay scenarios, drastically reducing the Mean Time to Resolution (MTTR).
                                </p>

                                <inu-code url="data/inugami/framework/monitoring.xml" tag="iolog_example"></inu-code>
                                <p>
                                    IOLOGs contain:
                                    - L'url d'appel avec le verb HTTP 
                                    - les différents Headers http de la requête entrante
                                    - Le payload de la requête
                                    - Le status de la réponse
                                    - la durée d'exécution de la requête
                                    - les différents headers de la réponse
                                    - et le payload de sortie
                                </p>
                                <ul>
                                    <li>The request URL and HTTP verb</li>
                                    <li>Incoming HTTP request headers</li>
                                    <li>The request payload</li>
                                    <li>The response status code</li>
                                    <li>Request execution duration (latency)</li>
                                    <li>Outgoing HTTP response headers</li>
                                    <li>The response payload</li>
                                </ul>

                                <p>
                                    All of this information is structured in a way that is easily understandable for human beings.
                                </p>

                                <p>
                                    Every transaction generates two distinct IOLOG entries: one for the incoming request
                                    and one for the outgoing response. This distinction is materialized by the <strong>lifecycle</strong>
                                    field in the MDC, which uses the values <code>in</code> and <code>out</code>.
                                </p>

                                <p>
                                    By default, IOLOGs track request and response content only for the following mimetypes:
                                </p>
                                <ul>
                                    <li>text</li>
                                    <li>application/json</li>
                                    <li>application/xml</li>
                                </ul>

                                <p>
                                    However, you can enable content tracking for additional types by providing a custom
                                    implementation of the DefaultIoLogContentDisplayResolverSPI interface.
                                </p>

                                <inu-code url="data/inugami/framework/monitoring.xml" tag="ioLogContentDisplayResolverSPI"></inu-code>

                                <p>
                                    The RequestData object contains all the information regarding the incoming request.
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="RequestData"></inu-code>

                                <cite class="success">
                                    <header>
                                        <i></i>
                                        <div>
                                            The structured data from IOLOGs enables real-time visualization through
                                            dedicated Kibana dashboards. Key metrics such as hit rates, response times (SLA),
                                            HTTP status distributions, and detailed error categorizations
                                        </div>
                                    </header>
                                </cite>
                                <figure>
                                    <img src="images/framework/kibana_iolog_low.png" alt="Kibana dashboard" width="90%" />
                                    <caption>
                                        <a href="images/framework/kibana_iolog.png" target="_blank">Show full size</a>
                                    </caption>
                                </figure>

                                <p>
                                   Inugami's structured IOLOGs turn Kibana into a powerful self-service 
                                    analytics tool. By applying a simple filter on <code>loggerName</code> 
                                    and <code>lifecycle</code>, anyone can transform raw logs into 
                                    high-level business and technical.
                                </p>
                                <figure>
                                    <img src="images/framework/kibana_iolog_edit.png" alt="Create display from IOLOG" width="90%" />
                                </figure>
                                <p>
                                    IOLOG include specific <em>MDC context</em> values to qualify these:
                                </p>


                                <strong>Application & Infrastructure Context:</strong>
                                <dl> 
                                    <dt>asset / artifactId</dt> <dd>The technical name and Maven artifactId of the application.</dd>

                                    <dt>applicationVersion / version / majorVersion</dt>
                                    <dd>The current, full, and major version numbers of the application.</dd>

                                    <dt>commitId / commitDate</dt>
                                    <dd>The Git commit hash and timestamp of the current build.</dd>

                                    <dt>env / hostname</dt>
                                    <dd>The deployment environment (dev, int, prod) and the server's name.</dd>

                                    <dt>instanceName / instanceNumber</dt>
                                    <dd>The name and index of the specific application instance or pod.</dd>

                                    <dt>groupId</dt>
                                    <dd>The Maven groupId of the current application.</dd>
                                </dl>

                                <strong>Request Mapping & Logic:</strong>
                                <dl> 
                                    <dt>appClass / appClassShortName / appMethod</dt> 
                                    <dd>The Java class (full and simple names) and method handling the REST call.</dd>

                                    <dt>appService / appSubService</dt>
                                    <dd>The functional name and sub-name of the REST endpoint.</dd>

                                    <dt>service / domain / subDomain</dt>
                                    <dd>The functional name, domain, and sub-domain of the invoked service.</dd>

                                    <dt>uri / url / urlPattern</dt>
                                    <dd>The URI, full URL, and the normalized URL pattern used for grouping requests (stripping path variables).</dd>

                                    <dt>verb / urlPatternVerb</dt>
                                    <dd>The HTTP verb and the combination of the URL pattern with the verb.</dd>
                                </dl>


                                <strong>Distributed Tracing & Security:</strong>
                                <dl> 
                                    <dt>traceId</dt>
                                    <dd>The global unique identifier propagated across all services to track the complete call chain.</dd>

                                    <dt>correlation_id</dt>
                                    <dd>Identifier for the user's session.</dd>

                                    <dt>conversation_id</dt>
                                    <dd>Identifier for a specific business process or workflow.</dd>

                                    <dt>request_id</dt>
                                    <dd>Internal identifier for the current specific request.</dd>

                                    <dt>authProtocol / principal</dt>
                                    <dd>The authentication type used and the current user's login/identity.</dd>
                                </dl>



                                <strong>Front-End & User Telemetry:</strong>
                                <dl> 
                                    <dt>deviceIdentifier</dt>
                                    <dd>A unique user ID stored on the front-end and sent with every request.</dd>

                                    <dt>deviceType / osVersion / userAgent</dt>
                                    <dd>The hardware type (mobile, tablet, desktop), OS version, and browser User-Agent.</dd>

                                    <dt>deviceIp / remoteAddress</dt>
                                    <dd>The user's IP address and the IP of the parent network equipment (e.g., proxy/load balancer).</dd>

                                    <dt>language / country</dt>
                                    <dd>The user's preferred language and country.</dd>

                                    <dt>deviceNetworkType / deviceNetworkSpeedLatency</dt>
                                    <dd>The type of network used and the real network latency measured by the front-end.</dd>

                                    <dt>deviceNetworkSpeedDown / deviceNetworkSpeedUp</dt>
                                    <dd>The front-end's download and upload speeds.</dd>
                                </dl>


                                <strong>Execution Status & Performance:</strong>
                                <dl> 
                                    <dt>duration</dt>
                                    <dd>Server-side processing time in milliseconds.</dd>

                                    <dt>httpStatus / status / globalStatus</dt>
                                    <dd>The HTTP status code, the execution status, and the overall outcome (success/error).</dd>

                                    <dt>methodInCause</dt>
                                    <dd>The specific method responsible for a failure/error.</dd>

                                    <dt>lifecycle</dt>
                                    <dd>The phase of the call (in/out).</dd>

                                    <dt>callType / callFrom</dt>
                                    <dd>The protocol type (REST, JMS, etc.) and the source of the call.</dd>
                                </dl>



                            </inu-doc-item>

                            <inu-doc-item title="PARTNERLOG" [level]="3" href="inugami/framework/monitoring#logs-types-partnerlog" id="logs-types-partnerlog">

                                <p>
                                    PARTNERLOG follow the exact same logic and formatting as IOLOGs. Their purpose is
                                    to trace calls between the current application and external web services.
                                </p>

                                <p>
                                    Since every application logs its own IOLOGs, one might theoretically assume that
                                    logging inter-service communication is redundant. However, infrastructure is often complex,
                                    involving network components (proxies, load balancers, caches, etc.) that may modify requests along the way.
                                </p>


                                <p>
                                    When different teams work on interconnected web services, PARTNERLOGs are the perfect
                                    tool to determine whether an issue originates from:
                                </p>

                                <ul>
                                    <li>The calling application</li>
                                    <li>The responding application</li>
                                    <li>An intermediary network component</li>
                                </ul>

                                <inu-code url="data/inugami/framework/monitoring.xml" tag="PARTNERLOG"></inu-code>

                                <p>
                                    Partnerlogs include specific <em>MDC context</em> values to qualify external exchanges
                                </p>
                                
                                <strong>Error Metadata:</strong>
                                <dl>
                                    <dt>errorCategory</dt>
                                    <dd>Category of the error.</dd>

                                    <dt>errorCode</dt>
                                    <dd>The partner's specific error code.</dd>


                                    <dt>errorDomain / errorSubDomain</dt>
                                    <dd>Functional domain and subdomain of the error.</dd>

                                    <dt>errorType</dt>
                                    <dd>The nature of the error (e.g., Functional, Technical).</dd>

                                    <dt>errorMessage / errorMessageDetail</dt>
                                    <dd>Summary and technical details of the error message.</dd>

                                    <dt>errorUrl</dt>
                                    <dd>Link to the partner's error documentation.</dd>
                                </dl>

                                <strong>Operational Insight:</strong>
                                <dl>
                                    <dt>errorExploitationError</dt>
                                    <dd>Boolean indicating if it is an infrastructure-level error.</dd>

                                    <dt>errorField</dt>
                                    <dd>The specific field in the data model causing the error.</dd>

                                    <dt>errorRetryable</dt>
                                    <dd>Indicates if a retry attempt is safe/possible.</dd>

                                    <dt>errorRollback</dt>
                                    <dd>Indicates if the error triggered a transaction rollback.</dd>

                                    <dt>errorStatus</dt>
                                    <dd>The HTTP status code associated with the error.</dd>
                                </dl>

                                <strong>Partner & Transaction Context</strong>
                                <dl>
                                    <dt>partner</dt>
                                    <dd>Name of the partner system.</dd>

                                    <dt>partnerType</dt>
                                    <dd>Protocol type (REST, JMS, SOAP, etc.).</dd>

                                    <dt>partnerUrl / partnerVerb</dt>
                                    <dd>The endpoint URL and HTTP verb used.</dd>

                                    <dt>partnerService / partnerSubService</dt>
                                    <dd>The specific service and sub-service invoked.</dd>

                                    <dt>lifecycle</dt>
                                    <dd>The transaction phase (in or out).</dd>
                                </dl>

                                <strong>Performance & Encoding:</strong>
                                <dl>
                                    <dt>partnerResponseDuration</dt>
                                    <dd>Execution time of the partner call (in milliseconds).</dd>

                                    <dt>partnerResponseStatus / partnerResponseMessage</dt>
                                    <dd>The HTTP status and response message from the partner.</dd>

                                    <dt>partnerRequestCharset / partnerResponseCharset</dt>
                                    <dd>Character encoding for the request and response.</dd>
                                </dl>

                            </inu-doc-item>

                            <inu-doc-item title="OTHERS" [level]="3" href="inugami/framework/monitoring#logs-types-iolog" id="logs-types-others">
                                <p>
                                    Beyond IOLOGs and PARTNERLOGs, Inugami enforces a rigorous log categorization
                                    framework. While these categories may not share the same complex logic as transaction
                                    logs, they provide a standardized structure for organizing application behavior
                                    and infrastructure events.
                                </p>
                                
                                <dl>
                                    <dt>ALERTING</dt>
                                    <dd>Logs triggered by threshold breaches or specific KPI alerts.</dd>

                                    <dt>BOOTSTRAP</dt>
                                    <dd>Records related to the application's startup sequence.</dd>

                                    <dt>CACHE</dt>
                                    <dd>Tracking the lifecycle and efficiency of caching mechanisms.</dd>

                                    <dt>CONFIG</dt>
                                    <dd>Detailed information regarding the active configurations at runtime.</dd>

                                    <dt>PLUGINS</dt>
                                    <dd>Insight into the lifecycle and status of application-specific plugins.</dd>

                                    <dt>XLLOG</dt>
                                    <dd>Critical infrastructure-level logs requiring immediate attention.</dd>

                                    <dt>EVENTS</dt>
                                    <dd>Tracing the lifecycle of events in event-driven architectures.</dd>

                                    <dt>SYSTEM</dt>
                                    <dd>Logs specific to the application's internal system operations.</dd>

                                    <dt>SECURITY</dt>
                                    <dd>Alerts regarding potential security threats or breaches.</dd>

                                    <dt>HEALTH</dt>
                                    <dd>Regular updates on the application's health status (heartbeats).</dd>

                                    <dt>TASK</dt>
                                    <dd>Dedicated to the lifecycle and execution of background jobs or scheduled processes.</dd>

                                    <dt>LOG_INITIALIZER</dt>
                                    <dd>A specialized log emitted at the end of the Inugami initialization. It captures all MDC fields to lock the index schema in dynamic indexing tools like Elasticsearch.</dd>
                                </dl>

                                <p>
                                    Each category is implemented as a dedicated <em>SLF4J</em> logger defined within the <code>Loggers</code> class, making them extremely easy to use.
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="XLLOG_usage"></inu-code>
                            </inu-doc-item>
                        </article>

                        <!--****************************************************************************************
                        ** Obfucation
                        ****************************************************************************************-->
                        <article>
                            <header>
                                <a [routerLink]="['/inugami/framework/monitoring']"><h2 id="log-masking">Log Data Sensitive Masking</h2></a>
                            </header>

                            <p>
                                While logs are invaluable tools, it is imperative to remain vigilant and ensure that
                                sensitive information is never leaked within them. Regulations such as <em>GDPR</em> have forced
                                companies to be much more rigorous regarding the data stored in their logging systems.
                            </p>
                            

                            <p>
                                To assist in this critical task, Inugami provides a specialized SLF4J Encoder.
                                This encoder allows for automated log masking through SPI (Service Provider Interface)
                                implementations, ensuring that sensitive data is protected before it ever reaches your
                                storage or indexing engine.
                            </p>

                            <p>
                                The <em>inugami_logs_obfuscator</em> module is specifically designed to handle log masking.
                                This dedicated module separates the obfuscation logic from the core framework,
                                providing a clean and pluggable security layer for any Inugami-based application.
                            </p>
                            <inu-code url="data/inugami/framework/monitoring.xml" tag="inugami_logs_obfuscator"></inu-code>

                            <p>
                                This encoder is a standard Logback encoder. To activate it, simply configure it within your logback.xml file.
                            </p>
                            <inu-code url="data/inugami/framework/monitoring.xml" tag="logback_obfuscator"></inu-code>

                            <p>
                                Out of the box, this module includes several specialized obfuscators:
                            </p>
                            <dl>
                                <dt>Password Obfuscation</dt>
                                <dd>Securely masks passwords across different formats using BasicPasswordObfuscator, XMLPasswordObfuscator, and JsonPasswordObfuscator.</dd>

                                <dt>Authorization Headers</dt>
                                <dd>The Authorization header is automatically masked via JsonAuthorizationObfuscator and BasicAuthorizationObfuscator.</dd>

                                <dt>CORS & Metadata Cleaning</dt>
                                <dd>
                                    To reduce log noise and prevent metadata leakage, the Access-Control-Allow-Headers 
                                    and Access-Control-Expose-Headers are obfuscated via their respective dedicated obfuscators.
                                </dd>

                                <dt>Cookie Protection</dt>
                                <dd>All session and tracking cookies are masked using the CookieObfuscator to prevent session hijacking via log exposure.</dd>
                            </dl>


                            <p>
                                Just like every other feature in the Inugami ecosystem, the obfuscation engine is 
                                fully extensible. You can enrich the framework with your own custom masking strategies
                                by implementing the <em>ObfuscatorSpi</em> interface. This SPI-based architecture ensures that
                                your specific business security requirements can be integrated seamlessly without
                                modifying the core framework.
                            </p>

                            <cite class="warning">
                                <header>
                                    <i></i>
                                    <div>
                                        When implementing custom obfuscators, Java SPI (Service Provider Interface) should always be prioritized.
                                    </div>
                                </header>
                                <p>
                                    Spring Boot initializes in two distinct phases; during the very first phase, 
                                    the Spring context is not yet loaded. However, logs containing sensitive information
                                    can still be produced during this early startup.
                                </p>

                                <p>
                                    Unlike Spring-managed beans, Java SPI interfaces are loaded as soon as the Logback
                                    encoder is instantiated. This ensures there is zero risk of data leakage during the
                                    application's bootstrap process, as the security layer is active before the first
                                    line of the Spring context even runs.
                                </p>
                            </cite>

                            <inu-code url="data/inugami/framework/monitoring.xml" tag="my_module_obfuscator"></inu-code>

                            <p>
                                The majority of information requiring masking will be found within <strong>IOLOG</strong>
                                or <strong>PARTNERLOG</strong> entries. In most use cases, these logs consist of JSON payloads.
                                Inugami is specifically designed to streamline the implementation of custom SPIs tailored
                                for this type of structured data.
                            </p>

                            <inu-code url="data/inugami/framework/monitoring.xml" tag="emailObfuscator"></inu-code>

                            <p>
                                Reliability is key when handling sensitive data. Inugami encourages a "test-first"
                                approach to validate your custom strategies. You can simulate log events and ensure 
                                your masking logic behaves as expected before deploying to production.
                            </p>

                            <inu-code url="data/inugami/framework/monitoring.xml" tag="emailObfuscatorTest"></inu-code>

                            <p>
                                l'obfuscation peut également permettre de réduire la taille de vos logs sur des données qui ont assez peu d'intéret dans vos logs
                            </p>

                            <cite class="success">
                                <header>
                                    <i>
                                    </i>
                                    <div>
                                        Log obfuscation can also be used to reduce log size by masking or truncating data
                                        that holds little to no value for your monitoring needs.
                                    </div>
                                </header>
                            </cite>
                        </article>

                        <!--****************************************************************************************
                        ** Metrics
                        ****************************************************************************************-->
                        <article>
                            <header>
                                <a [routerLink]="['/inugami/framework/monitoring']"><h2 id="metrics">Metrics</h2></a>
                            </header>

                            <p>
                                Logs are perfect tools for granular, real-time analysis. However, when it comes to
                                long-term indicator retention, the sheer volume of log data becomes a significant hurdle.
                            </p>

                            <p>
                                Metric indicators are much more lightweight, as they aggregate data over longer periods
                                (typically 1 minute).
                            </p>

                            <p>
                                The inugami_monitoring_sensors_default module provides out-of-the-box technical sensors
                                that export key performance indicators, including:
                            </p>

                           <dl>
                                <dt>CPU Consumption</dt>
                                <dd>Real-time monitoring of processor usage.</dd>

                                <dt>Memory Usage</dt>
                                <dd>Tracking of heap and non-heap memory allocation.</dd>

                                <dt>Thread Consumption</dt>
                                <dd>Monitoring of active, peak, and daemon thread counts to detect potential deadlocks or resource exhaustion.</dd>
                            </dl>

                            <p>
                                In our example, all these indicators are aggregated and stored within the <code>dev-demo-metrics-yyyy-MM-dd</code> index.
                            </p>

                            <p>
                                You can implement your own indicators using two different approaches:
                            </p>
                            <ul>
                                <li>
                                    Using the ServicesSensor class: This is the simplest and fastest method for standard use cases.
                                </li>

                                <li>
                                   Implementing the MonitoringSensor SPI: This approach offers deeper control for more complex requirements. 
                                </li>
                            </ul>
                            

                            <p>
                                While ServicesSensor is easier to use, the SPI implementation provides maximum flexibility 
                                or managing the sensor's lifecycle and data collection logic.
                            </p>


                            <inu-doc-item title="ServicesSensor" [level]="3" href="inugami/framework/monitoring#services-sensor" id="services-sensor">
                                
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="servicesSensor_addData"></inu-code>

                                <p>
                                  The <code>ServicesSensor</code> class provides the addData method, which allows you to add a list
                                  of <code>GenericMonitoringModelDTO</code> objects to its monitoring context.  
                                </p>

                                <inu-code url="data/inugami/framework/monitoring.xml" tag="GenericMonitoringModelDTO"></inu-code>

                                <cite class="danger">
                                    <header>
                                        <i></i>
                                        <div>
                                            The value defined within the <code>GenericMonitoringModelDTO</code> object must be a <strong>numeric value</strong>.
                                        </div>
                                    </header>
                                </cite>

                                <figure>
                                    <img src="images/framework/kpi_service_sensor.png" alt="KPI in Kibana" width="90%" />
                                </figure>
                            </inu-doc-item>


                            <inu-doc-item title="Sensor SPI" [level]="3" href="inugami/framework/monitoring#sensor-spi" id="sensor-spi">
                                <p>
                                    For implementing more complex sensors, you must implement the MonitoringSensor interface.
                                </p>

                                <inu-code url="data/inugami/framework/monitoring.xml" tag="MonitoringSensor"></inu-code>

                                <inu-code url="data/inugami/framework/monitoring.xml" tag="MonitoringSensorExample"></inu-code>

                                <cite class="success">
                                    <header>
                                        <i></i>
                                        <div>
                                            For complex sensors, it is highly recommended to implement the 
                                            MonitoringSensor through the Spring Context. This allows your sensor to
                                            leverage the full suite of Spring features, such as dependency injection 
                                            (Inversion of Control), automated database access, and seamless integration
                                            with other managed beans.
                                        </div>
                                    </header>
                                </cite>

                                <cite class="warning">
                                    <header>
                                        <i></i>
                                        <div>
                                            Sensor management is entirely asynchronous and executed in parallel.
                                            You must remain vigilant regarding the data passed to your sensors and
                                            how they retrieve information.
                                        </div>
                                    </header>
                                </cite>

                            </inu-doc-item>

                            <inu-doc-item title="KpiExtractorSPI" [level]="3" href="inugami/framework/monitoring#kpi_extractor_spi" id="kpi_extractor_spi">
                                <p>
                                    <strong>Many business indicators</strong> can be derived from incoming requests or
                                    server responses. In these cases, it is mandatory to use SPI implementations of the
                                    <code>KpiExtractorSPI</code> interface.
                                </p>

                                <p>
                                    Analyzing and retrieving data from these elements can be resource-intensive; therefore,
                                    we must ensure that this process never degrades the user experience. To achieve this,
                                    the service utilizing KpiExtractorSPI implementations performs these tasks asynchronously,
                                    decoupling business data extraction from the main execution flow.
                                </p>

                                <inu-code url="data/inugami/framework/monitoring.xml" tag="KpiExtractorSPI"></inu-code>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="KpiExtractorContext"></inu-code>

                                <cite class="success">
                                    <header>
                                        <i></i>
                                        <div>
                                            Request and response payloads are transformed into <em>Jackson JsonNode</em> objects
                                            <strong>only once</strong>. This architecture allows you to chain multiple KPI extractors
                                            without any performance degradation.
                                        </div>
                                    </header>
                                </cite>
                                
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="UserKpiExtractor"></inu-code>

                                 <figure>
                                    <img src="images/framework/kpi_service_sensor.png" alt="KPI from UserKpiExtractor in Kibana" width="90%" />
                                </figure>

                                 <cite class="warning">
                                    <header>
                                        <i></i>
                                        <div>
                                            To activate this feature and enable the execution of your <strong>KpiExtractorSPI</strong> implementations,
                                            you must set the following property in your configuration:
                                            <code>inugami.monitoring.interceptors.kpi.enabled=true</code>
                                        </div>
                                    </header>
                                </cite>
                            </inu-doc-item>
                        </article>


                        <!--****************************************************************************************
                        ** Metrics
                        ****************************************************************************************-->
                        <article>
                            <header>
                                <a [routerLink]="['/inugami/framework/monitoring']"><h2 id="mdcService">MdcService</h2></a>
                            </header>
                            <p>
                                The <code>MdcService</code> is a sophisticated wrapper around the <em>SLF4J Mapped Diagnostic Context</em> (MDC).
                                While standard MDC only handles strings, Inugami's MdcService manages complex types
                                (Dates, Booleans, Numbers) and ensures that your log context is automatically synchronized
                                with the global RequestContext.
                            </p>


                            <strong>Key Capabilities:</strong>
                            <dl>
                                <dt>Standardized Keys</dt>
                                <dd>It uses a predefined set of <code>MDCKeys</code> (Environment, Hostname, TraceID,
                                    CorrelationID) to ensure log consistency across all services.</dd>

                                <dt>Automatic Initialization</dt>
                                <dd>On every request, it automatically populates the context with device info, network speeds,
                                    and versioning metadata.</dd>

                                <dt>SPI Extensibility</dt>
                                <dd>Through LoggerMdcMappingSPI, you can define custom transformation rules for your context data.</dd>

                                <dt>Tracking Headers</dt>
                                <dd>It natively supports distributed tracing headers like X-Correlation-Id, X-B3-TraceId,
                                    and X-Conversation-Id.</dd>
                            </dl>

                            <inu-code url="data/inugami/framework/monitoring.xml" tag="MdcService"></inu-code>


                            <p><strong>Initialization and Lifecycle :</strong>
                                These methods ensure the logging context is synchronized with the application's state.
                            </p>
                            <dl>
                                <dt>getInstance</dt>
                                <dd>Returns the Singleton instance of the service.</dd>

                                <dt>initialize</dt>
                                <dd>The core setup method. it extracts data from the RequestContext (Environment, Hostname,
                                    Asset, Version) and standard headers (User-Agent, IP, Device Info) to populate the MDC
                                    immediately upon request entry.</dd>

                                <dt>onContextRefreshed</dt>
                                <dd>Automatically reloads SPI mappers (LoggerMdcMappingSPI) whenever the Spring context is refreshed.</dd>
                            </dl>


                            <p><strong>Context Enrichment (Setters)</strong>
                                These methods allow developers to add custom metadata to the current thread's logs.
                            </p>
                            <dl>
                                <dt>setMdc</dt>
                                <dd>
                                    The primary entry point for adding data. It features Smart Type Handling
                                    <ul>
                                        <li>
                                            Dates/Calendars: Formatted to yyyy-MM-dd'T'HH:mm:ss.sss.
                                        </li>
                                        <li>
                                            Java 8 Date API: Supports LocalDateTime and LocalDate with ISO formatting.
                                        </li>
                                        <li>
                                            Null Safety: If a value is null or empty, it automatically triggers a remove(key)
                                            to keep the context clean.
                                        </li>
                                    </ul>
                                </dd>

                                <dt>addMdc</dt>
                                <dd>Allows batch insertion of multiple key-value pairs.</dd>

                                <dt>deviceIdentifier, correlationId,traceId,</dt>
                                <dd>Specifically manages distributed tracing IDs. If no ID is provided, the service automatically
                                    generates and assigns a new <code>UUID</code>.</dd>
                            </dl>



                            <p><strong>Data Retrieval (Typed Getters :</strong>
                                Used to extract information from the context, often for logic branching or passing data to sub-systems.
                            </p>
                            <dl>
                                <dt>getMdc</dt>
                                <dd> Returns the raw String value from the context.</dd>

                                <dt>getInt,getLong,...</dt>
                                <dd>Provides safe parsing of MDC strings into numeric or boolean types, returning default
                                    values (0 or false) if the key is missing or invalid.</dd>

                                <dt>getLocalDateTime</dt>
                                <dd>Safely parses stored timestamps back into Java 8 date objects.</dd>

                                <dt>getAllMdcExtended</dt>
                                <dd>Returns a sorted map of the entire context, processed through any registered 
                                    <code>LoggerMdcMappingSPI</code> for custom data transformation.</dd>
                            </dl>


                            <p><strong>Advanced Error Mapping :</strong>
                            One of Inugami's most powerful features is how it structures error reporting.
                            </p>
                            <dl>
                                <dt>errorCode</dt>
                                <dd>Instead of a simple error message, this method deconstructs a complex ErrorCode object
                                    into multiple searchable dimensions: errorCategory, errorStatus, errorDomain,
                                    errorRetryable, etc.</dd>

                                <dt>hasError</dt>
                                <dd>A utility to check if the current context contains any error markers.</dd>

                                <dt>errorCodeRemove</dt>
                                <dd>A bulk cleanup method to remove all error-related MDC keys.</dd>
                            </dl>

                            <p><strong>Flow and Lifecycle Management :</strong>
                            Used to track the direction and success of operations.
                            </p>
                            <dl>
                                <dt>lifecycleIn,lifecycleOut </dt>
                                <dd>Tags logs as "Entry" or "Exit" points. For example on IOLOG</dd>

                                <dt>lifecycle</dt>
                                <dd>A high-level wrapper. It sets the lifecycle to "In", executes your functional code,
                                    and ensures the lifecycle tag is removed in a finally block, even if an exception occurs.</dd>

                                <dt>globalStatusSuccess, globalStatusError</dt>
                                <dd>ets a high-level status flag, perfect for creating "Success Rate" dashboards.</dd>
                            </dl>


                            <p><strong>Distributed Tracing & Cleanup</strong>
                            </p>
                            <dl>
                                <dt>getTrackingInformation</dt>
                                <dd>Returns a map containing the essential headers (X-Correlation-Id, X-Trace-Id, etc.)
                                    required to propagate the context when calling external partners or microservices.</dd>

                                <dt>clear, remove</dt>
                                <dd>Essential for memory management. clear() wipes the entire context, which is mandatory
                                    when threads are returned to a pool (e.g., in a Servlet container) to prevent context
                                    leaking between users.</dd>
                            </dl>


                            <p>
                                All essential information for monitoring—both technical and business-related—must be
                                defined within the MDC context to ensure it is available in your monitoring tools.
                            </p>

                            <cite class="success">
                                <header>
                                    <i></i>
                                    <div>
                                        By centralizing your metrics and metadata in the MDC, you create a single
                                        source of truth. This allows your monitoring platform (such as ELK) to correlate
                                        system health with business performance in real-time.
                                    </div>
                                </header>
                            </cite>

                            <inu-code url="data/inugami/framework/monitoring.xml" tag="mdcServiceUsage"></inu-code>
                            <cite class="success">
                                <header>
                                    <i></i>
                                    <div>
                                        In this example, we capture the <strong>volume</strong> and the <strong>total value</strong>
                                        of an order directly within the execution flow. By doing so, every log entry generated during the
                                        payment process will automatically include the order's <strong>financial weight</strong>
                                        in <strong>real-time</strong>.
                                    </div>
                                </header>
                            </cite>

                            

                            <p>
                                In SLF4J, MDC values are not typed, they are defined strictly as Strings.
                                If you are using MDC fields that represent non-string data (such as numbers, booleans, or dates), 
                                ou must inform Inugami of their actual types by implementing the MdcInitializerSpi interface.
                                 This ensures that the data is correctly serialized and indexed, allowing for accurate filtering 
                                 and mathematical aggregations in your monitoring tools.
                            </p>
                            <inu-code url="data/inugami/framework/monitoring.xml" tag="LoggerMdcMappingSPI"></inu-code>


                            <p>
                                Inugami also allows you to invoke an SPI Service to dynamically add data during log encoding by implementing the <code>MdcDynamicFieldSPI</code> interface.
                            </p>
                            <p>
                                This interface is particularly useful for injecting global system metrics or environmental
                                metadata that must be calculated at the exact moment a log entry is generated, ensuring
                                your logs always contain the most up-to-date contextual information without cluttering
                                your business logic.
                            </p>
                            <inu-code url="data/inugami/framework/monitoring.xml" tag="LoggerMdcMappingSPI"></inu-code>


                            <p>
                                If you are using dynamic indexes (which is not recommended for production but can be useful
                                during Demos or POCs), it is necessary to initialize the index with the various MDC fields.
                            </p>
                            <inu-code url="data/inugami/framework/monitoring.xml" tag="MdcInitializerSpi"></inu-code>


                        </article>


                        <!--****************************************************************************************
                        ** Interception
                        ****************************************************************************************-->
                        <article>
                            <header>
                                <a [routerLink]="['/inugami/framework/monitoring']"><h2 id="interception">Interception</h2></a>
                            </header>

                            <p>
                                By default, Inugami attempts to intercept all incoming requests to ensure maximum observability.
                                However, depending on the other frameworks you are using (such as Spring Actuator or Swagger),
                                you may need to exclude certain endpoints from interception.
                            </p>
                            
                            <p>
                                This can be achieved in two ways:
                            </p>
                            <ul>
                                <li>
                                    Via Configuration: By defining exclusion patterns in your properties file.
                                </li>
                                <li>Via SPI Service: By implementing the <code>Interceptable</code> SPI interface for fine-grained, programmatic control.</li>
                            </ul>

                            <inu-doc-item title="Exclud by properties" [level]="3" href="inugami/framework/monitoring#dependencies" id="exclud_by_properties">
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="exclud_url_interception"></inu-code>


                                 <dl>
                                    <dt>Regex Support</dt>
                                    <dd>The skip property accepts Regular Expressions. In the example above, <code>.*api-docs.*</code>
                                         ensures that any URL containing "api-docs" (regardless of what comes before or after)
                                         will be ignored by the Inugami interceptor.</dd>
                                    
                                    <dt>Delimiter</dt>
                                    <dd>Patterns are separated by a semicolon (;).</dd>
                                    
                                    <dt>Best Practice</dt>
                                    <dd>Always exclude your OpenAPI/Swagger endpoints and health check paths (like /actuator/health)
                                        to keep your business KPIs clean and reduce unnecessary processing overhead.</dd>
                                </dl>

                            </inu-doc-item>

                            <inu-doc-item title="Exclud by SPI" [level]="3" href="inugami/framework/monitoring#dependencies" id="MyTechnicalFilter">
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="interceptable"></inu-code>

                                <dl>
                                    <dt>Dynamic Logic</dt>
                                    <dd>Unlike the skip regex property which is static, Interceptable can change its behavior based on the application state or request content.</dd>

                                    <dt>Rich Context</dt>
                                    <dd>You have access to the RequestData object, which is already pre-populated with parsed information, making your filtering logic much simpler to write.</dd>

                                    <dt>Performance</dt>
                                    <dd>If a request is marked as non-interceptable here, Inugami will bypass the entire KPI extraction and MDC initialization flow for this specific call, saving resources.</dd>
                                </dl>
                            </inu-doc-item>

                        </article>
                </main>
            </section>


        
        </div>

    </div>

</section>