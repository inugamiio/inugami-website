<section id="framework-getting-started" class="page-section">
    <div class="page-section-content">
        <aside class="bd-sidebar">
            <framework-aside></framework-aside>
        </aside>
        <div class="bd-content">
            <section>
                    <header>
                    <h1>Inugami Framework : Monitoring</h1>
                </header>

                <!--################################################################################################
                # MAIN
                #################################################################################################-->
                <main>
                        <p>
                           Monitoring is a vital aspect of an application that should be considered from the design phase.
                           Retrofitting it into an existing system is a significant challenge.
                        </p>
                        <p>
                           Achieving granular application monitoring is a major challenge. Experience in extreme
                           operational environments shows that attempting to build such a solution without a dedicated
                           framework often leads to prohibitive technical debt.
                        </p>
                        <p>
                            Inugami was born from the need to supervise a massive mobile application, utilizing multiple
                            datacenters for its backend, all while maintaining an operational quality that allowed no
                            more than 5 minutes of annual downtime. The insights gained from these extreme constraints
                            led to the comprehensive suite of monitoring tools now integrated into Inugami.
                        </p>

                        <p>
                            A properly monitored application must provide real-time, precise insight into exactly what 
                            it is doing and whether its behavior is normal. Logs are the richest source of information 
                            an application can produce. They should not be viewed as an infrastructure cost, but as a
                            goldmine of information—not only for technical health but, more importantly,
                            for business intelligence.
                        </p>
                        <cite class="success">
                            <header>
                                <i></i>
                                <div>
                                   The real question we must ask ourselves is:
                                    how much will an application failure <strong>cost</strong> us—both in terms of <strong>reputation and financial impact</strong>?
                                </div>
                            </header>
                        </cite>

                                     
                        <inu-copy iconClass="icon ico-maven" label="copy maven dependency" [content]="mavenDependencies()"></inu-copy>
                        <div>
                            <inu-code url="data/inugami/framework/monitoring.xml" tag="dependencies_maven"></inu-code>
                        </div>
                        

                        <inu-copy iconClass="icon ico-java" label="copy java dependency" [content]="javaDependencies()"></inu-copy> 
                        <div>
                            <inu-code url="data/inugami/framework/monitoring.xml" tag="dependencies_java"></inu-code>
                        </div>
                        

                         <!--****************************************************************************************
                        ** ARCHETYPE
                        ****************************************************************************************-->
                        <article>
                            <header>
                                <a [routerLink]="['/inugami/framework/monitoring']"><h2 id="getting-started">Getting started</h2></a>
                            </header>

                            <p>
                               Inugami’s <a routerLink="/inugami/framework/exception">exception management documentation</a> highlights the framework’s extensive use of
                               the MDC (<strong>Mapped Diagnostic Context</strong>) to track errors. This management goes far beyond simple
                               logging. it is the very heart of Inugami’s monitoring strategy.
                            </p>

                            <p>
                                To unlock the full potential of logs, a tool capable of consuming a high-speed JSON
                                stream is essential. While several options exist, such as ElasticSearch/Kibana, Datadog or Splunk.
                            </p>
                            <cite class="success">
                                <header>
                                    <i></i>
                                    <div>
                                        the solution that is by far the most straightforward, performant, and advanced
                                        is Elasticsearch coupled with Kibana.
                                    </div>
                                </header>
                                <p>
                                    For more information on Elasticsearch and Kibana, you can visit 
                                    <a href="https://www.elastic.co/" target="_blank">the official website</a>, 
                                    which offers extensive documentation on the vast capabilities of these tools.
                                </p>
                            </cite>

                            <cite class="info">
                                <header>
                                    <i></i>
                                    <div></div>
                                </header>
                                <p>
                                    To demonstrate Inugami’s monitoring capabilities, the choice was made to integrate
                                    it with Elasticsearch and Kibana for this demo. The concepts discussed are generic
                                    and can be transposed to other tools. Only the creation and usage of information
                                    within the observation tool will differ.
                                </p>
                            </cite>


                            <p>
                                The objective of this demo is to demonstrate how to set up a relatively comprehensive
                                dashboard, all in a very simple manner. The dashboard in question is as follows:
                            </p>
                            <figure>
                                <img src="images/framework/kibana_low.png" alt="Kinaba dashboard" width="90%" />
                                <caption>
                                    <a href="images/framework/kibana.png" target="_blank">Show full size</a>
                                </caption>
                            </figure>
                            

                            <inu-doc-item title="Dependencies and configurations" [level]="3" href="inugami/framework/monitoring#dependencies" id="dependencies">
                                <cite class="info">
                                    <header>
                                        <i></i>
                                        <div>
                                            The example is based on the Inugami Maven archetype. 
                                        </div>
                                    </header>
                                    <p>
                                        For more information, please refer to the documentation:  <a  [routerLink]="['/inugami/framework/getting-started']" fragment="archetype">Archetype</a>.
                                    </p>
                                </cite>
                                <p>
                                    To enable monitoring in your application, you must add the following modules:
                                </p>


                                <dl>
                                    <dt>io.inugami.framework.interfaces (inugami_api_interfaces)</dt>
                                    <dd>The core of Inugami's interfaces and DTOs.</dd>

                                    <dt>io.inugami.framework.commons.spring (inugami_commons_spring)</dt>
                                    <dd>Inugami is agnostic of dependency injection engines (such as Spring or CDI).
                                        this module is required to expose its features through a specific injection engine.</dd>

                                    <dt>io.inugami.monitoring.springboot (inugami_monitoring_springboot)</dt>
                                    <dd>To enable monitoring for Spring Boot applications.</dd>

                                    <dt>io.inugami.logs.obfuscator (inugami_logs_obfuscator)</dt>
                                    <dd>Enables log obfuscation and includes appenders to transform logs into JSON format.</dd>

                                    <dt>io.inugami.monitoring.sensors.defaults (inugami_monitoring_sensors_default)</dt>
                                    <dd>To include Inugami's default technical sensors.</dd>

                                    <dt>io.inugami.monitoring.providers.logs (inugami_monitoring_providers_log)</dt>
                                    <dd>Enables the transmission of indicators via logs.</dd>
                                </dl>

                                <p>
                                    Your webapp module's <code>module-info.java</code> should look like this:
                                    <inu-code url="data/inugami/framework/monitoring.xml" tag="module_java_webapp"></inu-code>
                                </p>

                                <p>
                                    Logs must be transmitted to Elasticsearch in JSON format. To do this,
                                    the <code>io.inugami.logs.obfuscator.appender.JsonAppender</code> must be added to your <strong>logback.xml</strong> configuration.
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="elastic_appender"></inu-code>
                                <p>
                                    The <em>JsonAppender</em> requires several configuration parameters:
                                </p>

                                 <dl>
                                    <dt>mode</dt>
                                    <dd>Defines the provider for writing logs. Available modes are: file (default), elasticSearch, or logstash.</dd>
                                    
                                    <dt>host</dt>
                                    <dd>Specifies the service URL when using elasticSearch or logstash mode. </dd>
                                    
                                    <dt>headersMap</dt>
                                    <dd>Allows you to specify authentication or custom headers if your Elasticsearch instance requires them.</dd>
                                    
                                    <dt>index</dt>
                                    <dd>The Elasticsearch index name. This name is crucial for managing different environments and index retention policies.</dd>
                                    
                                    <dt>indexDatePattern</dt>
                                    <dd>Applies a time-based pattern to the index name to manage log retention. Log eviction is handled by deleting old indexes.</dd>
                                </dl>
                                    
                                <cite class="success">
                                    <header>
                                        <i></i>
                                        <div>
                                            By default, the <em>JsonAppender</em> sends logs to Elasticsearch using <em>Bulk</em> mode to ensure faster transmission speeds.
                                        </div>
                                    </header>
                                </cite>

                                <p>
                                    To implement an effective log retention policy, it is imperative to split logs across different appenders.
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="logback_full"></inu-code>
                                
                                <p>
                                    By default, the log level is set to <code>DEBUG</code>. This is not an error, but a deliberate
                                    choice to encourage configuring logs during the development phase to ensure they
                                    are properly categorized. Consequently, you can switch to INFO in production without
                                    worrying about log volume, while retaining the ability to safely switch back to
                                    DEBUG if necessary.
                                </p>

                                <p>
                                    By default, the Logback configuration outputs logs through two main appenders: the Standard Output
                                    (rendered asynchronously via AsyncAppender) and Elasticsearch (via the JsonAppender, which is natively asynchronous).
                                </p>
                                <p>
                                    The following specialized JsonAppenders are available:
                                </p>
                                
                                <dl>
                                    <dt>ELASTIC-DEFAULT</dt>
                                    <dd>The default appender that routes all standard logs to Elasticsearch.</dd>
                                    
                                    <dt>ELASTIC-IOLOG</dt>
                                    <dd>Dedicated to Input/Output logs (IOLOG), capturing request and response payloads.</dd>
                                    
                                    <dt>ELASTIC-PARTNERLOG</dt>
                                    <dd>Dedicated to communication logs with external web services (PARTNERLOG).</dd>
                                    
                                    <dt>ELASTIC-XLLOG</dt>
                                    <dd>Reserved for critical infrastructure logs.</dd>
                                    
                                    <dt>ELASTIC-METRICS</dt>
                                    <dd>Dedicated to KPI and performance indicators.</dd>
                                </dl>

                                <p>
                                    Each appender targets a different index, allowing for granular control over retention policies based on the nature of the logs.
                                </p>

                                <p>
                                    Logs may contain sensitive information. To prevent data leakage, Inugami mandates
                                    the use of the <em>ObfuscatorEncoder</em>. This Logback encoder enables the obfuscation
                                    of sensitive data <strong>through strategies</strong> defined via <em>SPI</em> (Service Provider Interface).
                                </p>

                                <p>The ObfuscatorEncoder also requires several parameters:</p>
                                <dl>
                                    <dt>forceNewLine</dt>
                                    <dd>Primarily used for file mode, this parameter forces a line break at the end of each log entry.</dd>

                                    <dt>encodeAsJson</dt>
                                    <dd>Enables the conversion of logs into JSON format.</dd>

                                    <dt>additionalFields</dt>
                                    <dd>You may need to include "static" information in your logs (such as cluster name, pod ID, etc.).
                                        These infrastructure-specific details can be defined within this parameter.</dd>

                                    <dt>pattern</dt>
                                    <dd>When serializing to JSON, a complex log pattern is no longer necessary.
                                         only the message is required. All other metadata will be transmitted 
                                         via the MDC context.</dd>
                                </dl>


                                <p>
                                    To ensure Inugami can monitor your application correctly, you must provide the following configuration to your project:
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="application.yaml"></inu-code>

                                <dl>
                                    <dt>env</dt>
                                    <dd>Defines your application's execution environment. This indicator will be included in all logs and metrics.</dd>

                                    <dt>application</dt>
                                    <dd>Configures the core information of the application (such as its groupId, artifactId, version, etc.).</dd>

                                    <dt>inugami.monitoring</dt>
                                    <dd>General configuration for Inugami monitoring.</dd>

                                    <dt>inugami.monitoring.interceptors.kpi</dt>
                                    <dd>Enables the KPI extractor for all incoming and outgoing requests of your application.</dd>

                                    <dt>inugami.monitoring.internal.interval</dt>
                                    <dd>Sets the default time interval between each metric transmission. The default is 
                                        <em>1 minute</em>, but for the purpose of this demo, it is reduced to 10 seconds (defined in milliseconds).</dd>

                                    <dt>inugami.monitoring.interceptor.url.skip</dt>
                                    <dd>Used to exclude specific URLs from Inugami monitoring (such as OpenAPI/Swagger views).</dd>

                                    <dt>inugami.monitoring.exception.show.detail.enabled</dt>
                                    <dd>Determines whether error details should be displayed. This parameter should be set to false in production environments.</dd>
                                </dl>


                                <p>
                                    To finalize your application's configuration, you simply need to enable Inugami by
                                    adding the Inugami base package to your <code>@ComponentScan</code> annotation.
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="springboot_application"></inu-code>

                                <p>
                                     <a  [routerLink]="['/inugami/framework/getting-started']" fragment="archetype">The archetype</a> includes a Docker 
                                     configuration file to spin up an Elasticsearch and Kibana instance, allowing you to test log transmission directly.
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="docker_compose"></inu-code>

                                <inu-code url="data/inugami/framework/monitoring.xml" tag="docker_compose_up"></inu-code>

                                <p>
                                    Once Elasticsearch and Kibana are up and running, you can import the Kibana configuration file included in the archetype.
                                </p>

                                <figure>
                                    <img src="images/framework/kibana_import.png" alt="Kinaba import" width="90%" />
                                </figure>

                                <cite class="success">
                                    <header>
                                        <i></i>
                                        <div>The environment is ready</div>
                                    </header>
                                    <p>
                                        all that’s left is to start the application to see the logs appear in Kibana.
                                        You can use the Postman collection provided in the archetype to call the various URLs of the demo application.
                                    </p>
                                </cite>
                                
                                <figure>
                                    <img src="images/framework/kibana_low.png" alt="Kinaba dashboard" width="90%" />
                                    <caption>
                                        <a href="images/framework/kibana.png" target="_blank">Show full size</a>
                                    </caption>
                                </figure>

                                <cite class="success">
                                    <header>
                                        <i></i>
                                        <div>
                                            <strong>Seamless Spring Boot Ecosystem Integration</strong>
                                            <p>
                                                Inugami isn't just a library; it's a natural extension of the Spring Boot ecosystem. 
                                                By leveraging component scanning, it delivers an enterprise-grade 
                                                monitoring stack—including Bulk ingestion and SPI obfuscation in minutes. 
                                                What would normally take months of senior-level R&D to build from scratch is activated 
                                                instantly without ever polluting your business logic.
                                            </p>
                                        </div>
                                    </header>
                                </cite>
                            </inu-doc-item>
                        </article>

                        <!--****************************************************************************************
                        ** Logs type
                        ****************************************************************************************-->
                        <article>
                            <header>
                                <a [routerLink]="['/inugami/framework/monitoring']"><h2 id="logs-types">Logs types</h2></a>
                            </header>


                            <inu-doc-item title="IOLOG" [level]="3" href="inugami/framework/monitoring#logs-types-iolog" id="logs-types-iolog">
                                <p>
                                    IOLOGs are the cornerstone of application observability. By providing an exhaustive audit trail 
                                    of every incoming and outgoing exchange, they allow developers to accurately reconstruct 
                                    and replay scenarios, drastically reducing the Mean Time to Resolution (MTTR).
                                </p>

                                <inu-code url="data/inugami/framework/monitoring.xml" tag="iolog_example"></inu-code>
                                <p>
                                    IOLOGs contain:
                                    - L'url d'appel avec le verb HTTP 
                                    - les différents Headers http de la requête entrante
                                    - Le payload de la requête
                                    - Le status de la réponse
                                    - la durée d'exécution de la requête
                                    - les différents headers de la réponse
                                    - et le payload de sortie
                                </p>
                                <ul>
                                    <li>The request URL and HTTP verb</li>
                                    <li>Incoming HTTP request headers</li>
                                    <li>The request payload</li>
                                    <li>The response status code</li>
                                    <li>Request execution duration (latency)</li>
                                    <li>Outgoing HTTP response headers</li>
                                    <li>The response payload</li>
                                </ul>

                                <p>
                                    All of this information is structured in a way that is easily understandable for human beings.
                                </p>

                                <p>
                                    Every transaction generates two distinct IOLOG entries: one for the incoming request
                                    and one for the outgoing response. This distinction is materialized by the <strong>lifecycle</strong>
                                    field in the MDC, which uses the values <code>in</code> and <code>out</code>.
                                </p>

                                <p>
                                    By default, IOLOGs track request and response content only for the following mimetypes:
                                </p>
                                <ul>
                                    <li>text</li>
                                    <li>application/json</li>
                                    <li>application/xml</li>
                                </ul>

                                <p>
                                    However, you can enable content tracking for additional types by providing a custom
                                    implementation of the DefaultIoLogContentDisplayResolverSPI interface.
                                </p>

                                <inu-code url="data/inugami/framework/monitoring.xml" tag="ioLogContentDisplayResolverSPI"></inu-code>

                                <p>
                                    The RequestData object contains all the information regarding the incoming request.
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="RequestData"></inu-code>

                                <cite class="success">
                                    <header>
                                        <i></i>
                                        <div>
                                            The structured data from IOLOGs enables real-time visualization through
                                            dedicated Kibana dashboards. Key metrics such as hit rates, response times (SLA),
                                            HTTP status distributions, and detailed error categorizations
                                        </div>
                                    </header>
                                </cite>
                                <figure>
                                    <img src="images/framework/kibana_iolog_low.png" alt="Kinaba dashboard" width="90%" />
                                    <caption>
                                        <a href="images/framework/kibana_iolog.png" target="_blank">Show full size</a>
                                    </caption>
                                </figure>

                                <p>
                                   Inugami's structured IOLOGs turn Kibana into a powerful self-service 
                                    analytics tool. By applying a simple filter on <code>loggerName</code> 
                                    and <code>lifecycle</code>, anyone can transform raw logs into 
                                    high-level business and technical.
                                </p>
                                <figure>
                                    <img src="images/framework/kibana_iolog_edit.png" alt="Create display from IOLOG" width="90%" />
                                </figure>
                                <p>
                                    IOLOG include specific <em>MDC context</em> values to qualify these:
                                </p>


                                <strong>Application & Infrastructure Context:</strong>
                                <dl> 
                                    <dt>asset / artifactId</dt> <dd>The technical name and Maven artifactId of the application.</dd>

                                    <dt>applicationVersion / version / majorVersion</dt>
                                    <dd>The current, full, and major version numbers of the application.</dd>

                                    <dt>commitId / commitDate</dt>
                                    <dd>The Git commit hash and timestamp of the current build.</dd>

                                    <dt>env / hostname</dt>
                                    <dd>The deployment environment (dev, int, prod) and the server's name.</dd>

                                    <dt>instanceName / instanceNumber</dt>
                                    <dd>The name and index of the specific application instance or pod.</dd>

                                    <dt>groupId</dt>
                                    <dd>The Maven groupId of the current application.</dd>
                                </dl>

                                <strong>Request Mapping & Logic:</strong>
                                <dl> 
                                    <dt>appClass / appClassShortName / appMethod</dt> 
                                    <dd>The Java class (full and simple names) and method handling the REST call.</dd>

                                    <dt>appService / appSubService</dt>
                                    <dd>The functional name and sub-name of the REST endpoint.</dd>

                                    <dt>service / domain / subDomain</dt>
                                    <dd>The functional name, domain, and sub-domain of the invoked service.</dd>

                                    <dt>uri / url / urlPattern</dt>
                                    <dd>The URI, full URL, and the normalized URL pattern used for grouping requests (stripping path variables).</dd>

                                    <dt>verb / urlPatternVerb</dt>
                                    <dd>The HTTP verb and the combination of the URL pattern with the verb.</dd>
                                </dl>


                                <strong>Distributed Tracing & Security:</strong>
                                <dl> 
                                    <dt>traceId</dt>
                                    <dd>The global unique identifier propagated across all services to track the complete call chain.</dd>

                                    <dt>correlation_id</dt>
                                    <dd>Identifier for the user's session.</dd>

                                    <dt>conversation_id</dt>
                                    <dd>Identifier for a specific business process or workflow.</dd>

                                    <dt>request_id</dt>
                                    <dd>Internal identifier for the current specific request.</dd>

                                    <dt>authProtocol / principal</dt>
                                    <dd>The authentication type used and the current user's login/identity.</dd>
                                </dl>



                                <strong>Front-End & User Telemetry:</strong>
                                <dl> 
                                    <dt>deviceIdentifier</dt>
                                    <dd>A unique user ID stored on the front-end and sent with every request.</dd>

                                    <dt>deviceType / osVersion / userAgent</dt>
                                    <dd>The hardware type (mobile, tablet, desktop), OS version, and browser User-Agent.</dd>

                                    <dt>deviceIp / remoteAddress</dt>
                                    <dd>The user's IP address and the IP of the parent network equipment (e.g., proxy/load balancer).</dd>

                                    <dt>language / country</dt>
                                    <dd>The user's preferred language and country.</dd>

                                    <dt>deviceNetworkType / deviceNetworkSpeedLatency</dt>
                                    <dd>The type of network used and the real network latency measured by the front-end.</dd>

                                    <dt>deviceNetworkSpeedDown / deviceNetworkSpeedUp</dt>
                                    <dd>The front-end's download and upload speeds.</dd>
                                </dl>


                                <strong>Execution Status & Performance:</strong>
                                <dl> 
                                    <dt>duration</dt>
                                    <dd>Server-side processing time in milliseconds.</dd>

                                    <dt>httpStatus / status / globalStatus</dt>
                                    <dd>The HTTP status code, the execution status, and the overall outcome (success/error).</dd>

                                    <dt>methodInCause</dt>
                                    <dd>The specific method responsible for a failure/error.</dd>

                                    <dt>lifecycle</dt>
                                    <dd>The phase of the call (in/out).</dd>

                                    <dt>callType / callFrom</dt>
                                    <dd>The protocol type (REST, JMS, etc.) and the source of the call.</dd>
                                </dl>



                            </inu-doc-item>

                            <inu-doc-item title="PARTNERLOG" [level]="3" href="inugami/framework/monitoring#logs-types-partnerlog" id="logs-types-partnerlog">

                                <p>
                                    PARTNERLOG follow the exact same logic and formatting as IOLOGs. Their purpose is
                                    to trace calls between the current application and external web services.
                                </p>

                                <p>
                                    Since every application logs its own IOLOGs, one might theoretically assume that
                                    logging inter-service communication is redundant. However, infrastructure is often complex,
                                    involving network components (proxies, load balancers, caches, etc.) that may modify requests along the way.
                                </p>


                                <p>
                                    When different teams work on interconnected web services, PARTNERLOGs are the perfect
                                    tool to determine whether an issue originates from:
                                </p>

                                <ul>
                                    <li>The calling application</li>
                                    <li>The responding application</li>
                                    <li>An intermediary network component</li>
                                </ul>

                                <inu-code url="data/inugami/framework/monitoring.xml" tag="PARTNERLOG"></inu-code>

                                <p>
                                    Partnerlogs include specific <em>MDC context</em> values to qualify external exchanges
                                </p>
                                
                                <strong>Error Metadata:</strong>
                                <dl>
                                    <dt>errorCategory</dt>
                                    <dd>Category of the error.</dd>

                                    <dt>errorCode</dt>
                                    <dd>The partner's specific error code.</dd>


                                    <dt>errorDomain / errorSubDomain</dt>
                                    <dd>Functional domain and subdomain of the error.</dd>

                                    <dt>errorType</dt>
                                    <dd>The nature of the error (e.g., Functional, Technical).</dd>

                                    <dt>errorMessage / errorMessageDetail</dt>
                                    <dd>Summary and technical details of the error message.</dd>

                                    <dt>errorUrl</dt>
                                    <dd>Link to the partner's error documentation.</dd>
                                </dl>

                                <strong>Operational Insight:</strong>
                                <dl>
                                    <dt>errorExploitationError</dt>
                                    <dd>Boolean indicating if it is an infrastructure-level error.</dd>

                                    <dt>errorField</dt>
                                    <dd>The specific field in the data model causing the error.</dd>

                                    <dt>errorRetryable</dt>
                                    <dd>Indicates if a retry attempt is safe/possible.</dd>

                                    <dt>errorRollback</dt>
                                    <dd>Indicates if the error triggered a transaction rollback.</dd>

                                    <dt>errorStatus</dt>
                                    <dd>The HTTP status code associated with the error.</dd>
                                </dl>

                                <strong>Partner & Transaction Context</strong>
                                <dl>
                                    <dt>partner</dt>
                                    <dd>Name of the partner system.</dd>

                                    <dt>partnerType</dt>
                                    <dd>Protocol type (REST, JMS, SOAP, etc.).</dd>

                                    <dt>partnerUrl / partnerVerb</dt>
                                    <dd>The endpoint URL and HTTP verb used.</dd>

                                    <dt>partnerService / partnerSubService</dt>
                                    <dd>The specific service and sub-service invoked.</dd>

                                    <dt>lifecycle</dt>
                                    <dd>The transaction phase (in or out).</dd>
                                </dl>

                                <strong>Performance & Encoding:</strong>
                                <dl>
                                    <dt>partnerResponseDuration</dt>
                                    <dd>Execution time of the partner call (in milliseconds).</dd>

                                    <dt>partnerResponseStatus / partnerResponseMessage</dt>
                                    <dd>The HTTP status and response message from the partner.</dd>

                                    <dt>partnerRequestCharset / partnerResponseCharset</dt>
                                    <dd>Character encoding for the request and response.</dd>
                                </dl>

                            </inu-doc-item>

                            <inu-doc-item title="OTHERS" [level]="3" href="inugami/framework/monitoring#logs-types-iolog" id="logs-types-others">
                                <p>
                                    Beyond IOLOGs and PARTNERLOGs, Inugami enforces a rigorous log categorization
                                    framework. While these categories may not share the same complex logic as transaction
                                    logs, they provide a standardized structure for organizing application behavior
                                    and infrastructure events.
                                </p>
                                
                                <dl>
                                    <dt>ALERTING</dt>
                                    <dd>Logs triggered by threshold breaches or specific KPI alerts.</dd>

                                    <dt>BOOTSTRAP</dt>
                                    <dd>Records related to the application's startup sequence.</dd>

                                    <dt>CACHE</dt>
                                    <dd>Tracking the lifecycle and efficiency of caching mechanisms.</dd>

                                    <dt>CONFIG</dt>
                                    <dd>Detailed information regarding the active configurations at runtime.</dd>

                                    <dt>PLUGINS</dt>
                                    <dd>Insight into the lifecycle and status of application-specific plugins.</dd>

                                    <dt>XLLOG</dt>
                                    <dd>Critical infrastructure-level logs requiring immediate attention.</dd>

                                    <dt>EVENTS</dt>
                                    <dd>Tracing the lifecycle of events in event-driven architectures.</dd>

                                    <dt>SYSTEM</dt>
                                    <dd>Logs specific to the application's internal system operations.</dd>

                                    <dt>SECURITY</dt>
                                    <dd>Alerts regarding potential security threats or breaches.</dd>

                                    <dt>HEALTH</dt>
                                    <dd>Regular updates on the application's health status (heartbeats).</dd>

                                    <dt>TASK</dt>
                                    <dd>Dedicated to the lifecycle and execution of background jobs or scheduled processes.</dd>

                                    <dt>LOG_INITIALIZER</dt>
                                    <dd>A specialized log emitted at the end of the Inugami initialization. It captures all MDC fields to lock the index schema in dynamic indexing tools like Elasticsearch.</dd>
                                </dl>

                                <p>
                                    Each category is implemented as a dedicated <em>SLF4J</em> logger defined within the <code>Loggers</code> class, making them extremely easy to use.
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="XLLOG_usage"></inu-code>
                            </inu-doc-item>
                        </article>
                </main>
            </section>


        
        </div>

    </div>

</section>