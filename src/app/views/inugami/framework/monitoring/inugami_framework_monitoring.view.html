<section id="framework-getting-started" class="page-section">
    <div class="page-section-content">
        <aside class="bd-sidebar">
            <framework-aside></framework-aside>
        </aside>
        <div class="bd-content">
            <section>
                    <header>
                    <h1>Inugami Framework : Monitoring</h1>
                </header>

                <!--################################################################################################
                # MAIN
                #################################################################################################-->
                <main>
                        <p>
                           Monitoring is a vital aspect of an application that should be considered from the design phase.
                           Retrofitting it into an existing system is a significant challenge.
                        </p>
                        <p>
                           Achieving granular application monitoring is a major challenge. Experience in extreme
                           operational environments shows that attempting to build such a solution without a dedicated
                           framework often leads to prohibitive technical debt.
                        </p>
                        <p>
                            Inugami was born from the need to supervise a massive mobile application, utilizing multiple
                            datacenters for its backend, all while maintaining an operational quality that allowed no
                            more than 5 minutes of annual downtime. The insights gained from these extreme constraints
                            led to the comprehensive suite of monitoring tools now integrated into Inugami.
                        </p>

                        <p>
                            A properly monitored application must provide real-time, precise insight into exactly what 
                            it is doing and whether its behavior is normal. Logs are the richest source of information 
                            an application can produce. They should not be viewed as an infrastructure cost, but as a
                            goldmine of information—not only for technical health but, more importantly,
                            for business intelligence.
                        </p>
                        <cite class="success">
                            <header>
                                <i></i>
                                <div>
                                   The real question we must ask ourselves is:
                                    how much will an application failure <strong>cost</strong> us—both in terms of <strong>reputation and financial impact</strong>?
                                </div>
                            </header>
                        </cite>

                                     
                        <inu-copy iconClass="icon ico-maven" label="copy maven dependency" [content]="mavenDependencies()"></inu-copy>
                        <div>
                            <inu-code url="data/inugami/framework/monitoring.xml" tag="dependencies_maven"></inu-code>
                        </div>
                        

                        <inu-copy iconClass="icon ico-java" label="copy java dependency" [content]="javaDependencies()"></inu-copy> 
                        <div>
                            <inu-code url="data/inugami/framework/monitoring.xml" tag="dependencies_java"></inu-code>
                        </div>
                        

                         <!--****************************************************************************************
                        ** ARCHETYPE
                        ****************************************************************************************-->
                        <article>
                            <header>
                                <a [routerLink]="['/inugami/framework/monitoring']"><h2 id="getting-started">Getting started</h2></a>
                            </header>

                            <p>
                               Inugami’s <a routerLink="/inugami/framework/exception">exception management documentation</a> highlights the framework’s extensive use of
                               the MDC (<strong>Mapped Diagnostic Context</strong>) to track errors. This management goes far beyond simple
                               logging. it is the very heart of Inugami’s monitoring strategy.
                            </p>

                            <p>
                                To unlock the full potential of logs, a tool capable of consuming a high-speed JSON
                                stream is essential. While several options exist, such as ElasticSearch/Kibana, Datadog or Splunk.
                            </p>
                            <cite class="success">
                                <header>
                                    <i></i>
                                    <div>
                                        the solution that is by far the most straightforward, performant, and advanced
                                        is Elasticsearch coupled with Kibana.
                                    </div>
                                </header>
                                <p>
                                    For more information on Elasticsearch and Kibana, you can visit 
                                    <a href="https://www.elastic.co/" target="_blank">the official website</a>, 
                                    which offers extensive documentation on the vast capabilities of these tools.
                                </p>
                            </cite>

                            <cite class="info">
                                <header>
                                    <i></i>
                                    <div></div>
                                </header>
                                <p>
                                    To demonstrate Inugami’s monitoring capabilities, the choice was made to integrate
                                    it with Elasticsearch and Kibana for this demo. The concepts discussed are generic
                                    and can be transposed to other tools. Only the creation and usage of information
                                    within the observation tool will differ.
                                </p>
                            </cite>


                            <p>
                                The objective of this demo is to demonstrate how to set up a relatively comprehensive
                                dashboard, all in a very simple manner. The dashboard in question is as follows:
                            </p>
                            <figure>
                                <img src="images/framework/kibana_low.png" alt="Kinaba dashboard" width="90%" />
                                <caption>
                                    <a href="images/framework/kibana.png" target="_blank">Show full size</a>
                                </caption>
                            </figure>
                            

                            <inu-doc-item title="Dependencies and configurations" [level]="3" href="inugami/framework/monitoring#dependencies" id="dependencies">
                                <cite class="info">
                                    <header>
                                        <i></i>
                                        <div>
                                            The example is based on the Inugami Maven archetype. 
                                        </div>
                                    </header>
                                    <p>
                                        For more information, please refer to the documentation:  <a  [routerLink]="['/inugami/framework/getting-started']" fragment="archetype">Archetype</a>.
                                    </p>
                                </cite>
                                <p>
                                    To enable monitoring in your application, you must add the following modules:
                                </p>


                                <dl>
                                    <dt>io.inugami.framework.interfaces (inugami_api_interfaces)</dt>
                                    <dd>The core of Inugami's interfaces and DTOs./dd>

                                    <dt>io.inugami.framework.commons.spring (inugami_commons_spring)</dt>
                                    <dd>Inugami is agnostic of dependency injection engines (such as Spring or CDI).
                                        this module is required to expose its features through a specific injection engine.</dd>

                                    <dt>io.inugami.monitoring.springboot (inugami_monitoring_springboot)</dt>
                                    <dd>To enable monitoring for Spring Boot applications.</dd>

                                    <dt>io.inugami.logs.obfuscator (inugami_logs_obfuscator)</dt>
                                    <dd>Enables log obfuscation and includes appenders to transform logs into JSON format.</dd>

                                    <dt>io.inugami.monitoring.sensors.defaults (inugami_monitoring_sensors_default)</dt>
                                    <dd>To include Inugami's default technical sensors.</dd>

                                    <dt>io.inugami.monitoring.providers.logs (inugami_monitoring_providers_log)</dt>
                                    <dd>Enables the transmission of indicators via logs.</dd>
                                </dl>

                                <p>
                                    Your webapp module's <code>module-info.java</code> should look like this:
                                    <inu-code url="data/inugami/framework/monitoring.xml" tag="module_java_webapp"></inu-code>
                                </p>

                                <p>
                                    Logs must be transmitted to Elasticsearch in JSON format. To do this,
                                    the <code>io.inugami.logs.obfuscator.appender.JsonAppender</code> must be added to your <strong>logback.xml</strong> configuration.
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="elastic_appender"></inu-code>
                                <p>
                                    The <em>JsonAppender</em> requires several configuration parameters:
                                </p>

                                 <dl>
                                    <dt>mode</dt>
                                    <dd>Defines the provider for writing logs. Available modes are: file (default), elasticSearch, or logstash.</dd>
                                    
                                    <dt>host</dt>
                                    <dd>Specifies the service URL when using elasticSearch or logstash mode. </dd>
                                    
                                    <dt>headersMap</dt>
                                    <dd>Allows you to specify authentication or custom headers if your Elasticsearch instance requires them.</dd>
                                    
                                    <dt>index</dt>
                                    <dd>The Elasticsearch index name. This name is crucial for managing different environments and index retention policies.</dd>
                                    
                                    <dt>indexDatePattern</dt>
                                    <dd>Applies a time-based pattern to the index name to manage log retention. Log eviction is handled by deleting old indexes.</dd>
                                </dl>
                                    
                                <cite class="success">
                                    <header>
                                        <i></i>
                                        <div>
                                            By default, the <em>JsonAppender</em> sends logs to Elasticsearch using <em>Bulk</em> mode to ensure faster transmission speeds.
                                        </div>
                                    </header>
                                </cite>

                                <p>
                                    To implement an effective log retention policy, it is imperative to split logs across different appenders.
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="logback_full"></inu-code>
                                
                                <p>
                                    By default, the log level is set to <code>DEBUG</code>. This is not an error, but a deliberate
                                    choice to encourage configuring logs during the development phase to ensure they
                                    are properly categorized. Consequently, you can switch to INFO in production without
                                    worrying about log volume, while retaining the ability to safely switch back to
                                    DEBUG if necessary.
                                </p>

                                <p>
                                    By default, the Logback configuration outputs logs through two main appenders: the Standard Output
                                    (rendered asynchronously via AsyncAppender) and Elasticsearch (via the JsonAppender, which is natively asynchronous).
                                </p>
                                <p>
                                    The following specialized JsonAppenders are available:
                                </p>
                                
                                <dl>
                                    <dt>ELASTIC-DEFAULT</dt>
                                    <dd>The default appender that routes all standard logs to Elasticsearch.</dd>
                                    
                                    <dt>ELASTIC-IOLOG</dt>
                                    <dd>Dedicated to Input/Output logs (IOLOG), capturing request and response payloads.</dd>
                                    
                                    <dt>ELASTIC-PARTNERLOG</dt>
                                    <dd>Dedicated to communication logs with external web services (PARTNERLOG).</dd>
                                    
                                    <dt>ELASTIC-XLLOG</dt>
                                    <dd>Reserved for critical infrastructure logs.</dd>
                                    
                                    <dt>ELASTIC-METRICS</dt>
                                    <dd>Dedicated to KPI and performance indicators.</dd>
                                </dl>

                                <p>
                                    Each appender targets a different index, allowing for granular control over retention policies based on the nature of the logs.
                                </p>

                                <p>
                                    Logs may contain sensitive information. To prevent data leakage, Inugami mandates
                                    the use of the <em>ObfuscatorEncoder</em>. This Logback encoder enables the obfuscation
                                    of sensitive data <strong>through strategies</strong> defined via <em>SPI</em> (Service Provider Interface).
                                </p>

                                <p>The ObfuscatorEncoder also requires several parameters:</p>
                                <dl>
                                    <dt>forceNewLine</dt>
                                    <dd>Primarily used for file mode, this parameter forces a line break at the end of each log entry.</dd>

                                    <dt>encodeAsJson</dt>
                                    <dd>Enables the conversion of logs into JSON format.</dd>

                                    <dt>additionalFields</dt>
                                    <dd>You may need to include "static" information in your logs (such as cluster name, pod ID, etc.).
                                        These infrastructure-specific details can be defined within this parameter.</dd>

                                    <dt>pattern</dt>
                                    <dd>When serializing to JSON, a complex log pattern is no longer necessary.
                                         only the message is required. All other metadata will be transmitted 
                                         via the MDC context.</dd>
                                </dl>


                                <p>
                                    To ensure Inugami can monitor your application correctly, you must provide the following configuration to your project:
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="application.yaml"></inu-code>

                                <dl>
                                    <dt>env</dt>
                                    <dd>Defines your application's execution environment. This indicator will be included in all logs and metrics.</dd>

                                    <dt>application</dt>
                                    <dd>Configures the core information of the application (such as its groupId, artifactId, version, etc.).</dd>

                                    <dt>inugami.monitoring</dt>
                                    <dd>General configuration for Inugami monitoring.</dd>

                                    <dt>inugami.monitoring.interceptors.kpi</dt>
                                    <dd>Enables the KPI extractor for all incoming and outgoing requests of your application.</dd>

                                    <dt>inugami.monitoring.internal.interval</dt>
                                    <dd>Sets the default time interval between each metric transmission. The default is 
                                        <em>1 minute</em>, but for the purpose of this demo, it is reduced to 10 seconds (defined in milliseconds).</dd>

                                    <dt>inugami.monitoring.interceptor.url.skip</dt>
                                    <dd>Used to exclude specific URLs from Inugami monitoring (such as OpenAPI/Swagger views).</dd>

                                    <dt>inugami.monitoring.exception.show.detail.enabled</dt>
                                    <dd>Determines whether error details should be displayed. This parameter should be set to false in production environments.</dd>
                                </dl>


                                <p>
                                    To finalize your application's configuration, you simply need to enable Inugami by
                                    adding the Inugami base package to your <code>@ComponentScan</code> annotation.
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="springboot_application"></inu-code>

                                <p>
                                     <a  [routerLink]="['/inugami/framework/getting-started']" fragment="archetype">The archetype</a> includes a Docker 
                                     configuration file to spin up an Elasticsearch and Kibana instance, allowing you to test log transmission directly.
                                </p>
                                <inu-code url="data/inugami/framework/monitoring.xml" tag="docker_compose"></inu-code>

                                <inu-code url="data/inugami/framework/monitoring.xml" tag="docker_compose_up"></inu-code>

                                <p>
                                    Once Elasticsearch and Kibana are up and running, you can import the Kibana configuration file included in the archetype.
                                </p>

                                <figure>
                                    <img src="images/framework/kibana_import.png" alt="Kinaba import" width="90%" />
                                </figure>

                                <cite class="success">
                                    <header>
                                        <i></i>
                                        <div>The environment is ready</div>
                                    </header>
                                    <p>
                                        all that’s left is to start the application to see the logs appear in Kibana.
                                        You can use the Postman collection provided in the archetype to call the various URLs of the demo application.
                                    </p>
                                </cite>
                                
                                <figure>
                                    <img src="images/framework/kibana_low.png" alt="Kinaba dashboard" width="90%" />
                                    <caption>
                                        <a href="images/framework/kibana.png" target="_blank">Show full size</a>
                                    </caption>
                                </figure>

                                <cite class="success">
                                    <header>
                                        <i></i>
                                        <div>
                                            <strong>Seamless Spring Boot Ecosystem Integration</strong>
                                            <p>
                                                Inugami isn't just a library; it's a natural extension of the Spring Boot ecosystem. 
                                                By leveraging component scanning, it delivers an enterprise-grade 
                                                monitoring stack—including Bulk ingestion and SPI obfuscation in minutes. 
                                                What would normally take months of senior-level R&D to build from scratch is activated 
                                                instantly without ever polluting your business logic.
                                            </p>
                                        </div>
                                    </header>
                                </cite>
                            </inu-doc-item>
                        </article>

                        <!--****************************************************************************************
                        ** Logs type
                        ****************************************************************************************-->
                        <article>
                            <header>
                                <a [routerLink]="['/inugami/framework/monitoring']"><h2 id="logs-types">Logs types</h2></a>
                            </header>


                            <inu-doc-item title="IOLOG" [level]="3" href="inugami/framework/monitoring#logs-types-iolog" id="logs-types-iolog">
                                <p>
                                    IOLOGs are the cornerstone of application observability. By providing an exhaustive audit trail 
                                    of every incoming and outgoing exchange, they allow developers to accurately reconstruct 
                                    and replay scenarios, drastically reducing the Mean Time to Resolution (MTTR).
                                </p>

                                <inu-code url="data/inugami/framework/monitoring.xml" tag="iolog_example"></inu-code>
                                <p>
                                    IOLOGs contain:
                                    - L'url d'appel avec le verb HTTP 
                                    - les différents Headers http de la requête entrante
                                    - Le payload de la requête
                                    - Le status de la réponse
                                    - la durée d'exécution de la requête
                                    - les différents headers de la réponse
                                    - et le payload de sortie
                                </p>
                                <ul>
                                    <li>The request URL and HTTP verb</li>
                                    <li>Incoming HTTP request headers</li>
                                    <li>The request payload</li>
                                    <li>The response status code</li>
                                    <li>Request execution duration (latency)</li>
                                    <li>Outgoing HTTP response headers</li>
                                    <li>The response payload</li>
                                </ul>

                                <p>
                                    All of this information is structured in a way that is easily understandable for human beings.
                                </p>

                                <p>
                                    Every transaction generates two distinct IOLOG entries: one for the incoming request
                                    and one for the outgoing response. This distinction is materialized by the <strong>lifecycle</strong>
                                    field in the MDC, which uses the values <code>in</code> and <code>out</code>.
                                </p>

                            </inu-doc-item>
                        </article>
                </main>
            </section>


             

        </div>



    </div>

</section>