<section id="framework-getting-started" class="page-section">
    <div class="container-fluid">
        <div class="row flex-xl-nowrap">
            <aside class="bd-sidebar">
                <framework-aside></framework-aside>
            </aside>
            <div class="bd-content">
                <section>
                     <header>
                       <h1>Inugami Framework : Getting started</h1>
                    </header>

                    <!--################################################################################################
                    # MAIN
                    #################################################################################################-->
                    <main>
                        <p>
                            To meet the requirements of <em>the Inugami project</em>, we developed a dedicated framework
                            designed to structure the application and manage internal monitoring and error handling.
                        </p>
                        <p>
                            Indeed, most development issues are common across projects. It was this very realization that led to the 
                            creation of the Inugami framework.
                        </p>
                        <p>
                           Ultimately, the goal of this framework is to ensure that any application is <em>production-ready</em> while
                           maintaining the highest quality standards.
                        </p>


                        <!--****************************************************************************************
                        ** ARCHETYPE
                        ****************************************************************************************-->
                        <article>
                                <header>
                                    <a href="inugami/framework/getting-started#archetype"><h2 id="archetype">Archetype</h2></a>
                                </header>
                                <div class="content">
                                    <p>
                                        To jumpstart your project, use the Inugami Spring Boot Maven archetype.
                                        It scaffolds a complete <em>Java 21</em> and <em>Spring Boot 3</em> environment 
                                        with Inugami ready to use out of the box.
                                    </p>

                                    <p>
                                        This is also an ideal case study for detailing the different functionalities 
                                        of the Inugami framework.
                                    </p>
                                    <inu-code url="data/inugami/inugami_gav.xml" tag="inugami_maven_springboot_run"></inu-code>
                                
                                    <p>
                                        You can find a sample Spring Boot application generated with this Maven archetype by following this link:
                                        <a href="https://github.com/inugamiio/inugami-demo" target="_blank">https://github.com/inugamiio/inugami-demo</a>
                                    </p>


                                    <inu-doc-item title="Archetype architecture" [level]="3" href="inugami/framework/getting-started#archetype-architecture" id="archetype-architecture">
                                        <p>
                                            The generated project follows a <em>Hexagonal Architecture</em>. This approach ensures a clean isolation of responsibilities 
                                            for each part of the application. While this architecture may be slightly confusing
                                            for less experienced developers, it will be explained in detail here.
                                        </p>
                                        
                                        <div class="row-reverse">
                                            <figure class="size-20 padding-right-4">
                                                <img src="images/framework/archetype-architecture.png" alt="archetype architecture" />
                                            </figure>

                                            <div class="size-fit">
                                                The project is broken down into the following modules:
                                                
                                                <dl>
                                                    <dt>demo-api</dt>
                                                    <dd>Contains all DTOs and interfaces used by the application core.</dd>

                                                    <dt>demo-core</dt>
                                                    <dd>The heart of the application. This module contains all the business logic.</dd>

                                                    <dt>demo-infrastructure</dt>
                                                    <dd>Handles database access and external web service calls to other applications.</dd>

                                                    <dt>demo-interfaces</dt>
                                                    <dd>The REST exposure layer of the application.</dd>

                                                    <dt>demo-webapp</dt>
                                                    <dd>The final module that assembles all other modules into a single Spring Boot application.</dd>
                                                </dl>
                                                
                                                <cite class="info">
                                                     <header>
                                                        <i></i>
                                                        <div>
                                                            By implementing the hexagonal architecture layers as distinct 
                                                            <em>Maven modules</em>, we can guarantee strong isolation between
                                                            the different parts of the application.
                                                        </div>
                                                    </header>
                                                    
                                                </cite>

                                                <cite class="info">
                                                    <header>
                                                        <i></i>
                                                        <div>
                                                            Each module is also pre-configured as a Java Module <em>(JPMS)</em>.
                                                        </div>
                                                    </header>
                                                </cite>

                                            </div>
                                            
                                        </div>
                                    </inu-doc-item>
                                </div>                                
                            </article>


                        <!--****************************************************************************************
                        ** First run
                        ****************************************************************************************-->
                        <article>
                            <header>
                                    <a href="inugami/framework/getting-started#first-run"><h2 id="first-run">First run</h2></a>
                            </header>
                             <div class="row-reverse">
                                <figure class="padding-right-4">
                                    <img src="images/framework/mvn-clean-install.png" alt="maven run" style="width: 100%; max-width: 25rem;" />
                                </figure>

                                <div class="size-fit">
                                    As with most Java projects, building the project only requires executing the following Maven command from the project root:
                                    <inu-code url="data/inugami/framework/source_code.xml" tag="mvn_clean_install" ></inu-code>

                                    <p>
                                        Compilation performance varies significantly depending on the hardware.
                                        For this example, the build process took approximately 2 minutes to 
                                        run all unit and integration tests.
                                    </p>
                                </div>
                            </div>

                            <p>
                                From your IDE, you can run the <em>com.my.project.webapp.Application</em> class to start the Spring Boot application.
                            </p>
                            
                            <figure>
                                    <img src="images/framework/run_01.png" alt="springboot run" width="70%"/>
                            </figure>
                            <figure>
                                    <img src="images/framework/run_02.png" alt="springboot run" width="70%" />
                            </figure>
                            
                            Once the application is up and running, you can access the <em>OpenAPI</em> documentation here:
                            <a href="http://localhost:8080/swagger-ui/index.html" target="_blank">http://localhost:8080/swagger-ui/index.html</a>

                            <figure>
                                    <img src="images/framework/openapi_01.png" alt="open api" width="70%" />
                            </figure>


                            <p>
                                A Postman collection is provided in the <em>local-integration-test</em> directory to help you test the generated application.
                            </p>
                            <figure>
                                    <img src="images/framework/postman_01.png" alt="postman call success" width="70%" />
                            </figure>

                            <p>
                                For every request to the application, a log named IOLOG is generated:
                            </p>
                            <ul>
                                <li>One upon the initial request</li>
                                <li>A second one upon the response</li>
                            </ul>
                            <p>
                                These IOLOGs allow you to precisely track the instructions sent to the server and follow
                                the different calls associated with a specific user.
                            </p>

                            <inu-code url="data/inugami/framework/source_code.xml" tag="iolog"></inu-code>

                            <p>
                                Every application must handle its errors, and the Postman collection also allows you to observe 
                                the application's behavior when an error occurs. Inugami includes a Spring service that 
                                intercepts all errors and returns a detailed error response compliant with the <em>RFC 9457</em> standard.
                            </p>
                            <cite class="info">
                                <header>
                                    <i></i>
                                    <div>
                                        If you would like to learn more about the RFC 9457 specification, 
                                        please refer to the following documentation: <a href="https://datatracker.ietf.org/doc/rfc9457/" target="_blank">https://datatracker.ietf.org/doc/rfc9457</a>
                                    </div>
                                </header>
                               
                            </cite>

                            <figure>
                                    <img src="images/framework/postman_02.png" alt="postman call success" width="70%" />
                            </figure>
                            
                            <inu-code url="data/inugami/framework/source_code.xml" tag="error_response"></inu-code>

                            <cite class="info">
                                <header>
                                    <i></i>
                                    <div>
                                        For further details on how Inugami manages errors, please refer to the relevant section :
                                        <a routerLink="/inugami/framework/exception">Exception management</a>
                                    </div>
                                </header>
                            </cite>
                        </article>

                        <!--****************************************************************************************
                        ** MODULES DETAILS
                        ****************************************************************************************-->
                        <article>
                            <header>
                                    <a href="inugami/framework/getting-started#modules-details"><h2 id="modules-details">Modules details</h2></a>
                            </header>

                            <inu-doc-item title="Module API" [level]="3" href="inugami/framework/getting-started#module-api" id="module-api">
                                <p>
                                    The demo-api module serves as the central contract layer. It houses all the DTOs used by the application core.
                                    Its purpose is to facilitate data exchange:
                                </p>

                                <ul>
                                    <li>Between REST controllers and the domain.</li>
                                    <li>Among internal core services.</li>
                                    <li>Between the core and the infrastructure layer.</li>
                                </ul>

                                <inu-code url="data/inugami/framework/source_code.xml" tag="demo-api"></inu-code>
                                <p>
                                    Following standard Java modularity, each module includes a module-info.java file at its root.
                                </p>

                                <cite class="danger">
                                    <header>
                                        <i></i>
                                        <div>
                                            It is mandatory for Java module names to match their base package. 
                                            Deviating from this standard will cause module import failures.
                                        </div>
                                    </header>
                                </cite>


                                <div class="row-reverse">
                                    <figure class="padding-right-4">
                                        <img src="images/framework/module_api_01.png" alt="module-api" width="256px" />
                                    </figure>

                                    <div class="size-fit">
                                        <p>
                                            The demo-api module is straightforward. We have implemented only one domain
                                        (<em>users</em>) for demonstration purposes. In a production-grade application,
                                        this identical structure would be replicated across all application domains.
                                        </p>
                                       
                                        <dl>
                                            <dt>UserDTO</dt>
                                            <dd>The primary DTO containing user information.</dd>

                                            <dt>UserDTOSearchRequestDTO</dt>
                                            <dd>The DTO containing the various search parameters for a user.</dd>

                                            <dt>UserFilters</dt>
                                            <dd>Information filtering requires knowing the criteria types (inclusive parameters, exact matches, range-based boundaries, etc.).</dd>

                                            <dt>UserErrors</dt>
                                            <dd>All domain-specific error codes are defined via an enumeration.</dd>


                                            <dt>IUserDao</dt>
                                            <dd>The interface for the user data access service.</dd>

                                            <dt>IUserService</dt>
                                            <dd>The main service providing CRUD operations (Create, Read, Update, Delete) for users.</dd>
                                        </dl>
                                    </div>
                                </div>


                                <inu-doc-item title="UserDTO" [level]="4" href="inugami/framework/getting-started#demo-api-userDto" id="demo-api-userDto">
                                    <inu-code url="data/inugami/framework/source_code.xml" tag="demo-api-userDto"></inu-code>
                                    <p>
                                        These DTOs follow standard Java conventions. <em>Lombok</em> is integrated to handle 
                                        the generation of redundant methods (getters, setters, etc.), reducing boilerplate code.
                                    </p>
                                    <cite class="danger">
                                        <header>
                                            <i></i>
                                            <div>All DTOs must define the following methods:</div>
                                        </header>
                                        <ul>
                                            <li>equals</li>
                                            <li>hashCode</li>
                                            <li>getters / setters</li>
                                        </ul>
                                        Additionally, they must implement the Serializable interface. Since DTOs may be 
                                        stored in collections or Maps, these methods are essential for their proper behavior.
                                    </cite>

                                    <p>
                                        To guarantee that these essential DTO methods function correctly, unit testing is necessary.
                                        Many projects neglect testing their DTOs; while this may seem excessive, they are at
                                        the very heart of the business logic. Tools like <em>Lombok</em> and <em>MapStruct</em> perform invisible
                                        transformations in the source code. If a DTO or an entity is modified, server responses can change.
                                        Such changes can cause side effects on the frontend or, even worse, within the business logic itself.
                                    </p>
                                    
                                    <p>
                                        Testing DTOs can be long and tedious, as you must ensure the integrity of the DTO's structure. 
                                        To assist with this, <em>Inugami</em> includes a utility class named UnitTestHelper. 
                                        This class provides numerous utilities to simplify unit testing, 
                                        including the <strong>assertDto</strong> method.
                                    </p>

                                    <p>
                                        The <em>UnitTestHelper</em> class is included in the inugami_commons_test module:
                                    </p>
                                    <inu-code url="data/inugami/inugami_gav.xml" tag="inugami_commons_test"></inu-code>

                                    <cite class="warning">
                                        <header>
                                            <i></i>
                                            <div>
                                                Even though it is a standard Java module (<em>io.inugami.commons.test</em>), 
                                                it should be added to your project using the test scope, unless you are building 
                                                a custom testing framework.
                                            </div>
                                        </header>
                                    </cite>

                                    <inu-code url="data/inugami/framework/source_code.xml" tag="demo-api-userDto-test"></inu-code>

                                    <p>
                                        We configure the assertDto context to validate the DTO’s integrity. This example covers:
                                    </p>
                                    <ul>
                                        <li><strong>toBuilder</strong> functionality.</li>
                                        <li><strong>No-argument and all-argument</strong> constructors.</li>
                                        <li><strong>Jackson serialization</strong> through a reference file (specified by fullArgConstructorRefPath).</li>
                                        <li><strong>Getter-based projection</strong> validation against reference data.</li>
                                        <li><strong>Standard Object methods</strong>: toString, equals, and hashCode.</li>
                                        <li><strong>Setter</strong> logic verification.</li>
                                    </ul>

                                    <cite class="success">
                                        <header>
                                            <i></i>
                                            <div>
                                                Inugami mandates the construction of a fully populated DTO for testing purposes. 
                                                Implementing a generator method for this DTO is highly beneficial for:
                                            </div>
                                        </header>
                                        <ul>
                                            <li><strong>Core-level</strong> business logic testing.</li>
                                            <li>Validating <strong>DTO/Entity</strong> mapping.</li>
                                            <li>Ensuring consistency between <strong>internal DTOs</strong> and the <strong>models</strong> used by REST interfaces.</li>
                                        </ul>
                                    </cite>
                                </inu-doc-item>

                                <inu-doc-item title="UserDTOSearchRequestDTO" [level]="4" href="inugami/framework/getting-started#demo-api-userDTOSearchRequestDTO" id="demo-api-userDTOSearchRequestDTO">
                                    <p>
                                        <em>UserDTOSearchRequestDTO</em> holds the search criteria and closely mirrors the UserDTO.
                                        Since this DTO is never stored in collections or maps, it does not need to override equals or hashCode.
                                    </p>
                                    
                                    
                                    <inu-code url="data/inugami/framework/source_code.xml" tag="demo-api-userDto-userDTOSearchRequestDTO"></inu-code>

                                    <p>
                                        Similar to the UserDTO test, this implementation specifies that <em>equals and hashCode validation should be bypassed</em>.
                                    </p>

                                    <inu-code url="data/inugami/framework/source_code.xml" tag="demo-api-userDto-userDTOSearchRequestDTO-test"></inu-code>
                                </inu-doc-item>


                                <inu-doc-item title="UserFilters" [level]="4" href="inugami/framework/getting-started#demo-api-userFilters" id="demo-api-userFilters">
                                    <p>
                                        The <em>UserFilters</em> utility class maps the search logic to the various fields provided in the <strong>UserDTOSearchRequestDTO</strong>.
                                    </p>
                                    <cite class="info">
                                        <header>
                                            <i></i>
                                            <div>
                                                At present, Inugami does not provide full support for search filters.
                                                Future releases will leverage them to automatically generate search predicates.
                                            </div>
                                        </header>
                                    </cite>
                                    
                                    
                                    <inu-code url="data/inugami/framework/source_code.xml" tag="demo-api-userFilters"></inu-code>

                                    <p>
                                        Unit testing is essential for validating class behavior. 
                                        <em>Inugami</em> contributes specialized utility methods to simplify the testing process for these objects.
                                    </p>

                                    <inu-code url="data/inugami/framework/source_code.xml" tag="demo-api-userFiltersTest"></inu-code>


                                    <p>
                                        This unit test provides a great example of how to use two especially useful methods from the UnitTestHelper class:
                                    </p>



                                    <dl>
                                        <dt>assertUtilityClassLombok</dt>
                                        <dd>This method validates that the @UtilityClass annotation is working as expected
                                            by checking that the target class meets all utility class requirements
                                            (e.g., private constructor, final class).
                                        </dd>

                                        <dt>assertText</dt>
                                        <dd>Arguably the most essential method in UnitTestHelper. It performs a complete
                                            object verification by using Jackson projection to compare the object's state.
                                        </dd>
                                    </dl>

                                    <cite class="info">
                                        <header>
                                            <i></i>
                                            <div>
                                                <strong>Tips: </strong> Use assertText to avoid writing dozens of manual
                                                assertEquals. It provides a visual diff in your CI/CD logs.
                                            </div>
                                        </header>
                                        <div class="images-flex">
                                            <figure>
                                                <img src="images/framework/asserttext-01.png" alt="assertText failure current value" />
                                            </figure>
                                            <figure>
                                                <img src="images/framework/asserttext-02.png" alt="assertText failure diff"/>
                                            </figure>
                                        </div>
                                        <p>
                                            If a test fails, the assertText method outputs the actual object projection 
                                            along with a differential comparison to the reference value. 
                                            Lines containing differences are marked in red for easy identification of the issues.
                                        </p>
                                    </cite>
                                </inu-doc-item>

                                <inu-doc-item title="Services interfaces" [level]="4" href="inugami/framework/getting-started#demo-api-service" id="demo-api-service">
                                    <p>
                                        To handle data related to the user domain, both a service class and a data access 
                                        class are required. Consequently, two interfaces for these services are defined within the API layer (IUserService and IUserDao).
                                    </p>
                                    <p>
                                        According to the archetype example, the services are limited to standard CRUD operations.
                                    </p>

                                    
                                    <inu-code url="data/inugami/framework/source_code.xml" tag="demo-api-iUserService"></inu-code>
                                    <p>
                                        Given that our service handles only pure CRUD operations, it can directly implement
                                        <em>the Inugami Crud interface</em>. This interface provides all the standard CRUD method definitions.
                                    </p>
                                    <inu-code url="data/inugami/framework/source_code.xml" tag="crud"></inu-code>

                                    <inu-code url="data/inugami/framework/source_code.xml" tag="demo-api-iUserDao"></inu-code>
                                    <p>
                                        The same applies to the DAO layer.
                                    </p>
                                    <inu-code url="data/inugami/framework/source_code.xml" tag="crudDao"></inu-code>
                                </inu-doc-item>
                            
                                <inu-doc-item title="UserErrors" [level]="4" href="inugami/framework/getting-started#demo-api-userErrors" id="demo-api-userErrors">
                                    <p>
                                        Exception management is often a thorny issue in application development. 
                                        Many projects create custom exceptions to implement their error-handling logic.
                                        While this approach is common, it is only relevant when a workaround or recovery
                                        action is actually possible. Unfortunately, in the majority of cases, no such workaround exists.
                                        It is therefore preferable to have an exception-handling mechanism that reflects
                                        the reality of modern applications.
                                    </p>
                                        
                                    <p>
                                        Another drawback of creating specific exceptions is the difficulty—or even 
                                        impossibility—of achieving high granularity. It is impractical to define a unique 
                                        exception for every potential error case. This approach mechanically forces 
                                        developers to reduce the number of exceptions, thereby drowning out the precision
                                        of error detection.
                                    </p>

                                    <inu-code url="data/inugami/framework/source_code.xml" tag="userErrors"></inu-code>

                                    <p>
                                       Error codes provide significant context, making them highly effective for both 
                                       MDC logging and frontend integration, particularly for handling form validation errors.
                                    </p>
                                    <inu-code url="data/inugami/framework/source_code.xml" tag="errorCode"></inu-code>

                                    <cite class="danger">
                                        <header>
                                            <i></i>
                                            <div>
                                                Error codes are required to be unique. To ensure compliance, unit tests must
                                                be implemented for all error enums within each domain.
                                            </div>
                                        </header>
                                        <p>
                                            To perform these tests, Inugami includes methods within the UnitTestHelper
                                            class to simplify their implementation:
                                        </p>
                                    </cite>

                                    <dl>
                                        <dt>assertErrorCodeUnique</dt>
                                        <dd>To verify that no duplicates are present within the enumerations.</dd>

                                        <dt>assertErrorCode</dt>
                                        <dd>To guarantee the proper definition of the various error codes.</dd>
                                    </dl>

                                    <inu-code url="data/inugami/framework/source_code.xml" tag="userErrorsTest"></inu-code>
                                    
                                    
                                </inu-doc-item>
                            </inu-doc-item>


                            <inu-doc-item title="Module CORE" [level]="3" href="inugami/framework/getting-started#module-core" id="module-core">
                                <p>
                                    <em>The core module</em> handles the implementation of business logic. Within the archetype,
                                     it is intentionally minimalist, focusing exclusively on executing <strong>CRUD actions</strong> for the user domain.
                                     Following this structure, the UserService is the sole class residing in this module.
                                </p>

                                <inu-code url="data/inugami/framework/source_code.xml" tag="core_module"></inu-code>

                                <p>
                                    The core module needs to include the API layer as a dependency in order to utilize the classes defined in that module.
                                </p>
                                <cite class="info">
                                    <header>
                                        <i></i>
                                        <div>
                                            Given the Spring Boot nature of the project, the core module relies on declaring
                                            the primary Spring modules to function correctly.
                                        </div>
                                    </header>
                                </cite>

                                <inu-doc-item title="Standard CRUD" [level]="4" href="inugami/framework/getting-started#module-core" id="module-core-standard-crud">
                                    <p>
                                        By using the Inugami Crud interface, we are mandated to implement the full set of CRUD operations 
                                        (refer to <a [routerLink]="['/inugami/framework/getting-started']" fragment="demo-api-service">the API module documentation</a>).
                                    </p>
                                    <inu-code url="data/inugami/framework/source_code.xml" tag="userService"></inu-code>
                                    <cite class="success">
                                        <header>
                                            <i></i>
                                            <div>
                                                The full implementation is available via the following link:
                                                <a href="https://github.com/inugamiio/inugami-demo/blob/main/demo-core/src/main/java/com/my/project/core/domain/user/UserService.java"
                                                target="_blank">UserService.java</a>
                                            </div>
                                        </header>
                                    </cite>

                                    <p>
                                        The first method to implement is the one responsible for creation. Its primary role
                                        is to <strong>validate</strong> the data received from the REST interface before invoking 
                                        the persistence layer for storage. This is a very standard pattern found in many projects.
                                    </p>
                                    <inu-code url="data/inugami/framework/source_code.xml" tag="userService_create"></inu-code>

                                    <cite class="success">
                                        <header>
                                            <i></i>
                                            <div>
                                                We can see that there is no workaround when data fails validation. 
                                                Rather than relying on custom exceptions, which are unnecessary here, 
                                                <em>Inugami</em> leverages error codes and the <strong>Asserts</strong> utility to enforce 
                                                <em>Design by Contract principles</em>.
                                                ( <a [routerLink]="['/inugami/framework/getting-started']" fragment="demo-api-userErrors">refer to error codes documentation</a>)
                                            </div>
                                        </header>
                                    </cite>

                                    <p>
                                        The <strong>Asserts</strong> utility class contains many different methods to perform validation, the main ones being:
                                    </p>

                                    <dl>
                                        <dt>assertNotNull</dt>
                                        <dd>Verifies that an object is not null (related methods: assertNull).</dd>

                                        <dt>assertNotEmpty</dt>
                                        <dd>Highly useful for collections or strings, verifying that they are not empty.</dd>

                                        <dt>assertTrue</dt>
                                        <dd>Verifies that a given condition is true (related methods: assertFalse).</dd>

                                        <dt>assertEquals</dt>
                                        <dd>Verifies the equality of two objects (related methods: assertNotEquals).</dd>

                                        <dt>assertRegexMatch</dt>
                                        <dd>Allows using Regular Expressions for data validation.(related methods: assertRegexNotMatch, assertRegexFind, assertRegexNotFind).</dd>

                                        <dt>assertHigher</dt>
                                        <dd>Verifies that a number is greater than a given value (includes related methods: assertLower, assertLowerOrEquals, assertHigherOrEquals).</dd>

                                        <dt>assertAfter</dt>
                                        <dd>For date validation (the related method assertBefore checks if a date is prior to a reference date).</dd>

                                        <dt>assertFileExists</dt>
                                        <dd>For file management (related methods: assertFileReadable, assertFileWritable, assertFileExecutable, assertFolderExists).</dd>
                                    </dl>

                                    <p>
                                        When validating a collection, you can use the <em>assertModel</em> method. This method iterates
                                        through the various elements of the collection to perform validation. Unlike other 
                                        assertion methods, it collects all encountered errors and groups them together 
                                        to return a complete list. This approach is essential 
                                        for scenarios such as form validation.
                                    </p>
                                    <p>
                                        To identify exactly which element is causing an issue during validation,
                                        the error code must include the element's index and the offending field. Consequently,
                                        the fromErrorCode method is used to return a builder, allowing for the creation of 
                                        a specific new error code with this information. All that remains is to specify 
                                        the field attribute using a pattern.
                                    </p>


                                    <inu-code url="data/inugami/framework/source_code.xml" tag="userService_create_error_test"></inu-code>
                                    <p>
                                        To ensure that the correct error codes are being triggered, you can use the <em>assertThrows</em> method provided by the <strong>UnitTestHelper</strong> utility.
                                    </p>

                                    <cite class="success">
                                        <header>
                                            <i></i>
                                            <div>
                                                The full implementation is available via the following link:
                                                <a href="https://github.com/inugamiio/inugami-demo/blob/main/demo-core/src/test/java/com/my/project/core/domain/user/UserServiceTest.java"
                                                target="_blank">UserService.java</a>
                                            </div>
                                        </header>
                                    </cite>
                                </inu-doc-item>
                                

                                

                                <inu-doc-item title="Design by Contract" [level]="4" href="inugami/framework/getting-started#module-core" id="module-core-dbc">
                                    <p>
                                        The <em>getById</em> method is the most representative of Design by Contract. 
                                        
                                    </p>
                                    <ul>
                                        <li>
                                            At the start of the method, we verify that the ID is a valid UID using a regular expression. 
                                            If it is not, the server returns the <em>READ_USER_UID_REQUIRED</em> error code (<strong>HTTP 400</strong>).
                                        </li>
                                        <li>
                                            At the end of the method, we verify that the DAO successfully found the user.
                                            If not, the <em>READ_USER_NOT_FOUND</em> error code is returned (<strong>HTTP 404</strong>).
                                        </li>
                                    </ul>
                                    <inu-code url="data/inugami/framework/source_code.xml" tag="userService_getById"></inu-code>

                                    <cite class="success">
                                        <header>
                                            <i></i>
                                            <div>
                                                The Asserts class includes two very common regular expressions:
                                            </div>
                                        </header>
                                        <dl class="no-flex">
                                            <dt>UID_REGEX</dt>
                                            <dd>Used for UID validation, following the pattern :
                                                <inu-code url="data/inugami/framework/source_code.xml" tag="UID_REGEX"></inu-code>
                                            </dd>

                                            <dt>EMAIL_REGEX</dt>
                                            <dd>Used for email address validation. This regex is compatible with HTML5 email validation standards.
                                                <inu-code url="data/inugami/framework/source_code.xml" tag="EMAIL_REGEX"></inu-code>
                                            </dd>
                                        </dl>
                                    </cite>

                                    <p>
                                        The advantage of <strong>Hexagonal Architecture</strong> lies in its ability to test each module independently
                                        and with extreme simplicity. The <strong>Core module</strong> can use mocks to simulate the behavior 
                                        of the <strong>Infrastructure module</strong>, allowing for the simulation of scenarios that would 
                                        be very complex to reproduce in reality. Furthermore, as the Core module contains 
                                        all the business logic, it must include extensive unit testing to ensure proper behavior.
                                        Relying solely on unit tests using <em>Mockito</em>, instead of Spring Boot integration tests,
                                        significantly optimizes execution time.
                                    </p>
                                    <inu-code url="data/inugami/framework/source_code.xml" tag="userServiceTest"></inu-code>

                                    <cite class="success">
                                        <header>
                                            <i></i>
                                            <div>
                                                By using assertText and assertThrows, you reduce your test code volume
                                            </div>
                                        </header>
                                        <p>
                                            This writing simplicity is what makes it possible to reach and maintain thousands 
                                            of unit tests without them becoming a burden for the team.
                                        </p>
                                    </cite>


                                    <p>
                                        The <em>UnitTestData</em> class is a cornerstone for writing unit tests with a consistent 
                                        and reliable dataset. By centralizing common constants (UIDs, Emails, Phone Numbers)
                                        and pre-built DTOs (like USER_1, USER_2), it ensures that all tests across the project
                                        use the same referential data. This significantly reduces "magic values" and boilerplate
                                        code when setting up mocks. Additionally, it integrates <em>DataGeneratorUtils</em> to provide
                                        random but structured data when specific values are not required.

                                    </p>
                                    <inu-code url="data/inugami/framework/source_code.xml" tag="UnitTestData"></inu-code>
                                    
                                </inu-doc-item>
                                

                                
                            </inu-doc-item>


                            <inu-doc-item title="Module INFRASTRUCTURE" [level]="3" href="inugami/framework/getting-started#module-infrastructure" id="module-infrastructure">
                                <p>
                                    The Infrastructure module is the most standard part of the framework compared to typical
                                    Spring Boot development. <em>Inugami</em> does not aim to replace <em>Spring</em>; instead,
                                    its purpose is to standardize and streamline its development.
                                </p>

                                <inu-code url="data/inugami/framework/source_code.xml" tag="UserDao"></inu-code>

                                <p>
                                    The <strong>UserDao</strong> implementation naturally implements the <strong>IUserDao</strong> interface.
                                    This DAO leverages a <em>Spring Data repository</em> and a <em>MapStruct mapper</em>.
                                    This approach is the most common in <em>Spring Boot</em> application development.
                                </p>

                                <p>
                                    Validation is already handled by the <strong>Core module</strong>. The DAO is only accessed through 
                                    services exposed by the Core. Consequently, performing checks within the DAO is unnecessary.
                                    In the event of a failure (such as a constraint violation), errors are allowed to bubble 
                                    up to the service. It is the service's responsibility to verify these constraints before
                                    invoking the DAO and to handle error cases as needed.
                                </p>
                                <cite class="success">
                                    <header>
                                        <i></i>
                                        <div>
                                            As a result, DAO code is considerably simplified, allowing it to focus solely
                                            on its primary objective: <strong>persistence</strong>.
                                        </div>
                                    </header>
                                </cite>

                                <inu-doc-item title="MapStruct Mappers" [level]="4" href="inugami/framework/getting-started#module-infrastructure-mapper" id="module-infrastructure-mapper">
                                   <cite class="danger">
                                        <header>
                                            <i></i>
                                            <div>
                                                <strong>Avoid Spring-managed Mappers</strong>:  Defining MapStruct mappers 
                                                as Spring Beans is a common but detrimental practice. 
                                            </div>
                                        </header>
                                        <p>
                                            It forces unit tests
                                            to depend on the Spring Context, significantly slowing down the test suite.
                                            <em>Inugami</em> advocates for stateless mappers approach. 
                                            This ensures that data transformation remains pure Java,
                                            enabling lightning-fast unit tests and eliminating the need for reflection
                                            or complex dependency injection within the mapping layer.
                                        </p>
                                    </cite>

                                    <p>
                                        <strong>Decoupled Mapper Configuration</strong>: To maintain strict separation between
                                        data transformation and the framework, Inugami recommends a two-step approach:

                                    </p>


                                    <dl>
                                        <dt>The Mapper Interface:</dt>
                                        <dd>
                                            Defined as a pure MapStruct interface. It remains
                                            framework-agnostic and fully testable in isolation.
                                        </dd>

                                        <dt>The Configuration Class:</dt>
                                        <dd>A dedicated Spring @Configuration class is used to
                                            expose the mapper as a Bean. This keeps the mapping logic clean while allowing
                                            the DAO to benefit from standard dependency injection.</dd>
                                    </dl>

                                    <inu-code url="data/inugami/framework/source_code.xml" tag="UserEntityMapper"></inu-code>

                                    <inu-code url="data/inugami/framework/source_code.xml" tag="DatasourceEntityMapperConfiguration"></inu-code>

                                    <p>
                                        Using the <strong>DatasourceEntityMapperConfiguration</strong> class within unit tests allows for
                                        the creation of real mapper instances. This dual approach enables you to test the
                                        DAO with actual mapping logic while simultaneously validating the configuration class itself.
                                        It ensures that the <strong>"wiring"</strong> of your infrastructure is verified
                                        long before reaching the integration phase.
                                    </p>

                                    <inu-code url="data/inugami/framework/source_code.xml" tag="UserDaoTest"></inu-code>

                                    <cite class="success">
                                        <header>
                                            <i></i>
                                            <div>
                                                <strong>Handling Complex Mapping</strong>: When a mapper requires
                                                complex transformation logic, it should delegate these actions to a
                                                dedicated Utility Class. This keeps the mapper interface declarative
                                                and easy to read, while centralizing complex logic in reusable, stateless,
                                                and easily testable utility methods.
                                            </div>
                                        </header>
                                    </cite>
                                </inu-doc-item>

                            </inu-doc-item>
                        </article>
                    </main>
                </section>
            </div>
        </div>
    </div>
</section>