<section id="framework-getting-started" class="page-section">
    <div class="page-section-content">
        <aside class="bd-sidebar">
            <framework-aside></framework-aside>
        </aside>
        <div class="bd-content">
            <section>
                <header>
                     <h1>Inugami Framework : Exception management</h1>
                </header>


                <main>
                    <p>
                        Exception management is often a thorny issue in application development. 
                        Many projects create custom exceptions to implement their error-handling logic.
                        While this approach is common, it is only relevant when a workaround or recovery
                        action is actually possible. Unfortunately, in the majority of cases, no such workaround exists.
                        It is therefore preferable to have an exception-handling mechanism that reflects
                        the reality of modern applications.
                    </p>
                        
                    <p>
                        Another drawback of creating specific exceptions is the difficulty—or even 
                        impossibility—of achieving high granularity. It is impractical to define a unique 
                        exception for every potential error case. This approach mechanically forces 
                        developers to reduce the number of exceptions, thereby drowning out the precision
                        of error detection.
                    </p>

                    <p>Inugami's error management is distributed across three key modules, each serving a specific purpose in the lifecycle of an exception:</p>
                    <dl>
                        <dt>inugami_api_interfaces</dt>
                        <dd>The heart of the system. Defines error concepts and houses the <code>Asserts</code> engine.</dd>

                        <dt>inugami_monitoring_springboot</dt>
                        <dd>The bridge to SpringBoot, ensuring standardized API responses.</dd>

                        <dt>inugami_monitoring_core</dt>
                        <dd>The tracking layer, recording every error code within <code>IOLOG</code> for total traceability.</dd>

                        <dt>inugami_commons_test</dt>
                        <dd>To assist us with unit testing</dd>
                    </dl>

                    
                     <inu-copy iconClass="icon ico-maven" label="copy maven dependency" [content]="mavenDependencies()"></inu-copy>
                     <inu-code url="data/inugami/framework/source_code_exception.xml" tag="dependencies_maven"></inu-code>

                     <inu-copy iconClass="icon ico-java" label="copy java dependency" [content]="javaDependencies()"></inu-copy> 
                     <inu-code url="data/inugami/framework/source_code_exception.xml" tag="dependencies_java"></inu-code>

                    <!--************************************************************************************************
                    ** ERROR CODE
                    *************************************************************************************************-->
                    <article>
                            <header>
                                <a [routerLink]="['/inugami/framework/exception']" fragment="error-code"><h2 id="error-code">Error Code</h2></a>
                            </header>
                            <div class="content">
                                <p>
                                    Generic error strings often lead to integration bugs and poor maintainability. 
                                    <strong>To address this issue, Inugami has opted to use enumerations 
                                    to list all error codes.</strong>
                                </p>
                                <p>
                                    By using Enums, each functional domain defines its own closed set of 
                                    errors. This approach provides <strong>auto-completion</strong> for 
                                    developers, prevents duplication, and ensures that every error 
                                    code is unique and properly categorized.
                                </p>

                                <inu-code url="data/inugami/framework/source_code.xml" tag="userErrors"></inu-code>

                                
                                <p>
                                    Error codes are more than just identifiers; they are information carriers. 
                                    The concept of error codes is highly granular, as they can carry 
                                    a wealth of information. The <code>ErrorCode</code> interface is 
                                    designed to embody this concept.
                                </p>


                                <inu-code url="data/inugami/framework/source_code.xml" tag="errorCode"></inu-code>

                                <cite class="danger">
                                    <header>
                                        <i></i>
                                        <div>
                                            Error codes are required to be unique. To ensure compliance, unit tests must
                                            be implemented for all error enums within each domain.
                                        </div>
                                    </header>
                                    <p>
                                        To perform these tests, Inugami includes methods within the UnitTestHelper
                                        class to simplify their implementation:
                                    </p>
                                </cite>

                                <dl>
                                    <dt>assertErrorCodeUnique</dt>
                                    <dd>To verify that no duplicates are present within the enumerations.</dd>

                                    <dt>assertErrorCode</dt>
                                    <dd>To guarantee the proper definition of the various error codes.</dd>
                                </dl>

                                <inu-code url="data/inugami/framework/source_code.xml" tag="userErrorsTest"></inu-code>
                            </div>
                    </article>

                    <!--************************************************************************************************
                    ** CheckedException / UncheckedException
                    *************************************************************************************************-->
                    <article>
                            <header>
                                <a [routerLink]="['/inugami/framework/exception']" fragment="exception-type"><h2 id="exception-type">Exception types</h2></a>
                            </header>
                            <div class="content">
                                <p>
                                    Inugami offers two specialized exception types to match different architectural needs:
                                </p>
                                <dl>
                                    <dt>CheckedException</dt>
                                    <dd>
                                        Inherits from <code>Exception</code>. 
                                        It forces the developer to handle the error in the method signature. 
                                        Use this when a <strong>compensating action</strong> or <strong>fallback 
                                        strategy</strong> is required at the call site.
                                    </dd>

                                    <dt>UncheckedException</dt>
                                    <dd>
                                        <strong>UncheckedException</strong>: Inherits from <code>RuntimeException</code> 
                                        and is the standard for most Inugami projects. It allows the error to 
                                        bubble up to the <strong>Global Error Handler</strong>, keeping 
                                        your business logic clean and focused on the "happy path".
                                    </dd>
                                </dl>

                                <p>
                                    Standard exceptions usually stop the execution flow at the first error. However, for 
                                    complex operations like form validation, you often need to report all issues 
                                    simultaneously.
                                </p>
                                <p>
                                    <strong>The <code>UncheckedException</code> class has a child variant called 
                                    <code>MultiUncheckedException</code>. This type of exception is dedicated to 
                                    collecting multiple <code>UncheckedException</code> instances. In practice, 
                                    this class is used for form validation to check a complete data set and 
                                    return all field errors to the frontend at once.</strong>
                                </p>
                                <cite class="success">
                                    <header>
                                        <i></i>
                                        <div>
                                            <strong>Optimized UX</strong>: By using <code>MultiUncheckedException</code>, 
                                            the frontend receives a structured list of all invalid fields in a single 
                                            response. This allows you to highlight every error on the form 
                                            immediately, significantly improving the user experience compared 
                                            to "one-at-a-time" error reporting.
                                        </div>
                                    </header>
                                </cite>

                                <p>
                                    Efficiency in development is one of Inugami's core promises. 
                                    <strong>The <code>Asserts.assertModel</code> method is a prime example of the 
                                    <code>MultiUncheckedException</code> class in action. When a service needs 
                                    to validate a complete dataset in a single pass, it is essential to provide 
                                    the frontend with a report of all erroneous fields.</strong>
                                </p>
                                <p>
                                    By abstracting the error collection logic, <strong>Inugami’s approach to 
                                    this type of validation makes the code remarkably concise.</strong> Instead 
                                    of writing repetitive loops, developers can use a functional DSL to 
                                    define constraints that automatically populate the response.
                                </p>
                                <inu-code url="data/inugami/framework/source_code.xml" tag="userService_create"></inu-code>
                            </div>
                    </article>
                    

                    <!--************************************************************************************************
                    ** CheckedException / UncheckedException
                    *************************************************************************************************-->
                    <article>
                            <header>
                                <a [routerLink]="['/inugami/framework/exception']" fragment="asserts"><h2 id="asserts">Asserts</h2></a>
                            </header>

                            <p>
                                In many frameworks, validation is an afterthought. In Inugami, it is a 
                                first-class citizen. <strong>The <code>Asserts</code> class is the 
                                cornerstone of Inugami, providing the full power behind its logic.</strong>
                            </p>
                            <p>
                                By centralizing all validation logic into a single, fluent API, Inugami 
                                ensures that business rules are not only enforced but also consistently 
                                documented and reported to the frontend.
                            </p>

                            <inu-code url="data/inugami/framework/source_code.xml" tag="userService_create"></inu-code>
                                <p>
                                    The <strong>Asserts</strong> utility class contains many different methods to perform validation, the main ones being:
                                </p>

                                <dl>
                                    <dt>assertNotNull</dt>
                                    <dd>Verifies that an object is not null (related methods: assertNull).</dd>

                                    <dt>assertNotEmpty</dt>
                                    <dd>Highly useful for collections or strings, verifying that they are not empty.</dd>

                                    <dt>assertTrue</dt>
                                    <dd>Verifies that a given condition is true (related methods: assertFalse).</dd>

                                    <dt>assertEquals</dt>
                                    <dd>Verifies the equality of two objects (related methods: assertNotEquals).</dd>

                                    <dt>assertRegexMatch</dt>
                                    <dd>Allows using Regular Expressions for data validation.(related methods: assertRegexNotMatch, assertRegexFind, assertRegexNotFind).</dd>

                                    <dt>assertHigher</dt>
                                    <dd>Verifies that a number is greater than a given value (includes related methods: assertLower, assertLowerOrEquals, assertHigherOrEquals).</dd>

                                    <dt>assertAfter</dt>
                                    <dd>For date validation (the related method assertBefore checks if a date is prior to a reference date).</dd>

                                    <dt>assertFileExists</dt>
                                    <dd>For file management (related methods: assertFileReadable, assertFileWritable, assertFileExecutable, assertFolderExists).</dd>
                                </dl>

                                <p>
                                    When validating a collection, you can use the <em>assertModel</em> method. This method iterates
                                    through the various elements of the collection to perform validation. Unlike other 
                                    assertion methods, it collects all encountered errors and groups them together 
                                    to return a complete list. This approach is essential 
                                    for scenarios such as form validation.
                                </p>
                                <p>
                                    To identify exactly which element is causing an issue during validation,
                                    the error code must include the element's index and the offending field. Consequently,
                                    the fromErrorCode method is used to return a builder, allowing for the creation of 
                                    a specific new error code with this information. All that remains is to specify 
                                    the field attribute using a pattern.
                                </p>


                                <inu-code url="data/inugami/framework/source_code.xml" tag="userService_create_error_test"></inu-code>
                                <p>
                                    To ensure that the correct error codes are being triggered, you can use the <em>assertThrows</em> method provided by the <strong>UnitTestHelper</strong> utility.
                                </p>

                                <cite class="success">
                                    <header>
                                        <i></i>
                                        <div>
                                            The full implementation is available via the following link:
                                            <a href="https://github.com/inugamiio/inugami-demo/blob/main/demo-core/src/test/java/com/my/project/core/domain/user/UserServiceTest.java"
                                            target="_blank">UserService.java</a>
                                        </div>
                                    </header>
                                </cite>

                                <p>Each validation method in the <code>Asserts</code> class can be used in different ways:</p>
                                <ul>
                                    <li><strong>Generic</strong>: Without a specific error code, defaults to <code>"err-undefine"</code>.</li>
                                    <li><strong>With Message</strong>: Provides a custom message while keeping the generic code.</li>
                                    <li><strong>With Supplier</strong>: Uses a <code>Supplier&lt;String&gt;</code> for dynamic message generation.</li>
                                    <li><em>Best Practice</em>: Always define a specific <strong>ErrorCode</strong> to ensure full traceability.</li>
                                </ul>

                                <inu-code url="data/inugami/framework/source_code_exception.xml" tag="asserts_usage"></inu-code>
                    </article>


                    <!--************************************************************************************************
                    ** Server response
                    *************************************************************************************************-->
                    <article>
                            <header>
                                <a [routerLink]="['/inugami/framework/exception']" fragment="repsonse"><h2 id="repsonse">Server response</h2></a>
                            </header>

                            <p>
                                <strong>When an error occurs, the server must provide a clear response containing 
                                details about the encountered issue.</strong> This is where the 
                                <code>inugami_monitoring_springboot</code> module comes in, ensuring every 
                                exception is transformed into a standardized, readable format.
                            </p>

                            <p>
                                This responsibility is handled by the <code>inugami_monitoring_springboot</code> module. 
                                Specifically, <strong>error handling is managed by the <code>DefaultExceptionHandlerService</code> class</strong>, 
                                which centralizes all exception translation logic.
                            </p>

                            <inu-code url="data/inugami/framework/source_code_exception.xml" tag="server_response"></inu-code>

                            
                            <p>
                                Inugami also generates logs known as IOLOGs to trace all incoming and outgoing server traffic.
                                When an error occurs, these logs capture all relevant diagnostic information. Furthermore,
                                they allow for <em>Service Quality</em> (QoS) measurement by comparing successful <em>IOLOG</em>
                                entries against those in error.
                            </p>                            
                            <inu-code url="data/inugami/framework/source_code_exception.xml" tag="iologError"></inu-code>
                            
                            
                            <p> By default, Inugami operates in a <strong>detailed mode</strong> for error message generation.
                                This provides developers with maximum context during the debugging phase in local or development environments.
                            </p>

                            <inu-code url="data/inugami/framework/source_code_exception.xml" tag="server_response_reduce_config"></inu-code>

                            <inu-code url="data/inugami/framework/source_code_exception.xml" tag="server_response_reduce"></inu-code>

                            <inu-doc-item title="Exploitation error" [level]="3" href="inugami/framework/getting-started#exploitation-error" id="exploitation-error">
                                <p>
                                    As defined in the <strong>Error Codes</strong> section, specific exceptions 
                                    can be flagged as operational errors using the <code>exploitationError</code> field.
                                    
                                </p>

                                <inu-code url="data/inugami/framework/source_code_exception.xml" tag="xllog_error_code"></inu-code>

                                <inu-code url="data/inugami/framework/source_code_exception.xml" tag="xllog_logback"></inu-code>

                                <inu-code url="data/inugami/framework/source_code_exception.xml" tag="xllog"></inu-code>

                                
                                <cite class="success">
                                    <header>
                                        <i></i>
                                        <div>
                                            Inugami also populates the <em>errorUrl</em> MDC field to provide operators
                                            with a direct link to the relevant documentation page when an issue occurs.
                                        </div>
                                    </header>
                                </cite>
                                
                            </inu-doc-item>


                            <inu-doc-item title="Dynamic Metadata Enrichment" [level]="3" href="inugami/framework/getting-started#dynamic-meta" id="dynamic-meta">

                                <p>
                                    In certain scenarios, you may need to inject additional context into an error response dynamically.
                                    Inugami facilitates this through the ProblemAdditionalFieldBuilder SPI interface.
                                    Following the standard Inugami extensibility pattern, these builders can be declared in two ways:
                                </p>
                                
                                <dl>
                                    <dt>Standard Java SPI</dt>
                                    <dd>By registering the implementation in <code>module-info.java</code>.</dd>

                                    <dt>Spring Bean</dt>
                                    <dd>By simply defining the class as a <code>@Component</code> within the Spring context.</dd>
                                </dl>

                                <p>
                                    <strong>How it works:</strong> 
                                </p>
                                <p>
                                    The <code>DefaultExceptionHandlerService</code> automatically detects all available
                                    implementations and executes them during the exception processing phase.
                                    This allows you to append custom fields to the final <code>ProblemDTO</code> without modifying
                                    the core handling logic.
                                </p>


                                <inu-doc-item title="Defined as Java SPI" [level]="4" href="inugami/framework/getting-started#dynamic-meta-spi" id="dynamic-meta-spi">
                                    <inu-code url="data/inugami/framework/source_code_exception.xml" tag="MyProblemAdditionalFieldSPIModule"></inu-code>
                                    <inu-code url="data/inugami/framework/source_code_exception.xml" tag="MyProblemAdditionalFieldSPI"></inu-code>
                                </inu-doc-item>
                                

                                <inu-doc-item title="Defined as Spring bean" [level]="4" href="inugami/framework/getting-started#dynamic-meta-spring" id="dynamic-meta-spring">
                                    <inu-code url="data/inugami/framework/source_code_exception.xml" tag="MyProblemAdditionalField"></inu-code>
                                </inu-doc-item>
                                
                                <p>
                                    Providing this implementation flexibility ensures there are <strong>no limits</strong> 
                                    to the logic applied during error detection.
                                </p>
                                
                                <p>
                                    Since you have full access to the execution context (via SPI or Spring beans), 
                                    you can trigger advanced side effects. For example:
                                </p>
                                
                                <cite class="success">
                                    <header>
                                        <i></i>
                                        <div>
                                            <strong>Proactive Remediation</strong>: 
                                        </div>
                                    </header>
                                    <div>
                                        In the event of a critical infrastructure 
                                        failure, you can implement a builder that <strong>automatically creates a Jira ticket</strong> 
                                        or sends an urgent Slack alert, ensuring the resolution procedure starts the 
                                        moment the error is detected.
                                    </div>
                                </cite>


                            </inu-doc-item>

                            <inu-doc-item title="Dynamic Error code resolver" [level]="3" href="inugami/framework/getting-started#dynamic-resolver" id="dynamic-resolver">
                                <p>
                                    Frameworks like JPA, Hibernate, or Spring Security have their own exception hierarchies
                                    and do not natively support Inugami error codes.
                                </p>
                                <p>
                                    To maintain a consistent error contract across your entire application, Inugami provides
                                    the <code>ErrorCodeResolver</code> SPI. This allows you to "catch and translate" external exceptions
                                    into fully documented Inugami error codes.
                                </p>


                                <inu-code url="data/inugami/framework/source_code_exception.xml" tag="ErrorCodeResolver"></inu-code>

                                <dl>
                                    <dt>Consistency</dt>
                                    <dd>Your API always returns a ProblemDTO with a structured errorCode, regardless of the error's origin.</dd>

                                    <dt>Flexibility</dt>
                                    <dd>Define your resolvers as standard Java SPI (via module-info.java) for core modules,
                                        or as Spring beans (@Component) for application-level logic.
                                    </dd>

                                    <dt>Fallthrough Logic</dt>
                                    <dd>By returning null when an exception is not recognized,
                                        you allow the next resolver in the chain to process it,
                                        ensuring a clean Chain of Responsibility.
                                    </dd>
                                </dl>

                                <inu-code url="data/inugami/framework/source_code_exception.xml" tag="ErrorCodeResolverExample"></inu-code>

                            </inu-doc-item>
                    </article>


                </main>
            </section>
        </div>
    </div>
</section>